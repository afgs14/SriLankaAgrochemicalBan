#
#
#                                 4YP SCRIPT
#            Investigating the consequences of Sri Lanka's agrochemical ban on biodiversity and human nutrition
#

# Packages ---------------------------------------------------------------------
# Loading packages -------------------------------------------------------------
## Only loading the ones I actually use later on here. 
library(tidyverse)
library(ggpubr)
library(RColorBrewer)
library(arm)
library(ggthemes)
library(patchwork)
library(psych)
library(scales)
library(lme4)
library(bootStepAIC)
library(plotrix)
library(RColorBrewer)
library(tibble)
library(sf)
library(fuzzyjoin)
library(car)
library(geojsonio)
library(broom) 
library(viridis)
library(sf)
library(mapproj)
library(units)
library(rphylopic)
library(scales)

# SECTION 1 - PROCESSING DATA --------------------------------------------------
# 1.1. Loading data from computer (change source later) -------------------
data_SHY <- read_csv("DCSFlattenedData2.csv")    # Gross extent sown, gross extent harvested and average yield per net ha, by region, irrigation type and year 2004/2005 maha to 2022 yala  
data_zone_alloc <- read_csv("ZoneAllocation.csv")    # Climate zone of each region
data_zone_km <- read_csv("Data_region_km2.csv")
data_population <- read_csv("Data_SL_pop.csv")
data_rice_var <- read_csv("Data_rice_var.csv")
data_rice_nutri <- read_csv("Data_nutri_rice.csv")
data_FDA_nutri <- read_csv("Data_FDA_nutri.csv")
data_chaudhary_brooks <- read_csv("Chaudhary_and_Brooks_CFs.csv")
data_ecoregion_alloc <- read_csv("EcoregionAllocation.csv")  
data_tree_cover_total <- read_csv("Data_SL_tree_cover_2020.csv")
Data_region_link <- read_csv("Data_region_link.csv")
ecoregions <- st_read("Terrestrial_Ecoregions.geojson")
data_hh_expenditure <- read_csv("Houeshold_expenditure.csv")  
SL_districts <- geojson_read("https://raw.githubusercontent.com/wmgeolab/geoBoundaries/c3eef3778e5738cfb9ef13289be7b604780e835a/releaseData/gbOpen/LKA/ADM2/geoBoundaries-LKA-ADM2.geojson",  what = "sp")
map <- read_sf("https://raw.githubusercontent.com/wmgeolab/geoBoundaries/c3eef3778e5738cfb9ef13289be7b604780e835a/releaseData/gbOpen/LKA/ADM2/geoBoundaries-LKA-ADM2.geojson")
districts <- st_read("https://raw.githubusercontent.com/wmgeolab/geoBoundaries/c3eef3778e5738cfb9ef13289be7b604780e835a/releaseData/gbOpen/LKA/ADM2/geoBoundaries-LKA-ADM2.geojson")

# 1.2. Making names consistent, removing spaces, replacing NAs with 0 ----------
## GROSS area SOWN, HARVESTED and YIELD per harvest, region and irrigation type
data_SHY <-
  data_SHY %>%
  mutate_if(is.character, str_to_title) %>%
  mutate(Region = str_replace(Region, "\\*", ""),
         Region = str_replace(Region, "Mahaweli'h'", "Mahaweli_H"),
         Region = str_replace(Region, "Mahweli 'H'", "Mahaweli_H"), 
         Region = str_replace(Region, "Mahaweli 'H'", "Mahaweli_H"),
         Region = str_replace(Region, " ", "_"),
         Region = str_replace(Region, "Uda_Walawe", "Udawalawe"),
         Region = str_replace(Region, "Killinochchi\\*", "Killinochchi"),
         Region = str_replace(Region, "Mulativu\\*", "Mulativu"),
         Region = str_replace(Region, "Mannar\\*", "Mannar"),
         Harvest = str_replace(Harvest, " ","_"),
         Harvest = str_replace(Harvest, "21/22_Maha", "2021/2022_Maha"),
         Harvest = str_replace(Harvest, "2020/21_Maha", "2020/2021_Maha")) 
# 1.3. Dealing with Special Areas (Mahaweli H and Udawalawe) -------------------
  # These need to be allocated into districts (as they are subsets of districts, but listed separately)
    ## This means I can't show them on the map, and it's inconsistent because some of the time they're allocated in their Regions. 
    ## Allocation assumptions
      ### I have allocated based on Divisional Secretariats (level below District), and how they are divided between Districts
        #### Adding 8/10 of Mahaweli H to Anuradhapura; 2/10 to Kurunegala
        #### Adding 5/7 of Udawalawe to Hambantota, 1/7 to Ratnapura and 1/7 to Moneragala
    ## Allocation methods:
      ### Sown and Harvested: just need to add values together. 
      ### Yield: made weighted average - based on proportion of land in new 'Region' from Mahaweli / Udawalawe and original 'Region'. 

# Sown and Harvested - adding proportions to relevant Regions:
data_SHY2 <- data_SHY %>%
  pivot_wider(names_from = c(Region, SHY, Irrigation_type), values_from = Value) %>%
  mutate(Anuradhapura_Sown_Major2 = Anuradhapura_Sown_Major + (0.8 * ifelse(is.na(Mahaweli_H_Sown_Major), 0, Mahaweli_H_Sown_Major)),
         Anuradhapura_Sown_Minor2 = Anuradhapura_Sown_Minor + (0.8 * ifelse(is.na(Mahaweli_H_Sown_Minor), 0, Mahaweli_H_Sown_Minor)),
         Anuradhapura_Sown_Rainfed2 = Anuradhapura_Sown_Rainfed + (0.8 * ifelse(is.na(Mahaweli_H_Sown_Rainfed), 0, Mahaweli_H_Sown_Rainfed)),
         
         Anuradhapura_Harvested_Major2 = Anuradhapura_Harvested_Major + (0.8 * ifelse(is.na(Mahaweli_H_Harvested_Major), 0, Mahaweli_H_Harvested_Major)),
         Anuradhapura_Harvested_Minor2 = Anuradhapura_Harvested_Minor + (0.8 * ifelse(is.na(Mahaweli_H_Harvested_Minor), 0, Mahaweli_H_Harvested_Minor)),
         Anuradhapura_Harvested_Rainfed2 = Anuradhapura_Harvested_Rainfed + (0.8 * ifelse(is.na(Mahaweli_H_Harvested_Rainfed), 0, Mahaweli_H_Harvested_Rainfed)),
         
         Kurunegala_Sown_Major2 = Kurunegala_Sown_Major + (0.2 * ifelse(is.na(Mahaweli_H_Sown_Major), 0, Mahaweli_H_Sown_Major)),
         Kurunegala_Sown_Minor2 = Kurunegala_Sown_Minor + (0.2 * ifelse(is.na(Mahaweli_H_Sown_Minor), 0, Mahaweli_H_Sown_Minor)), 
         Kurunegala_Sown_Rainfed2 = Kurunegala_Sown_Rainfed + (0.2 * ifelse(is.na(Mahaweli_H_Sown_Rainfed), 0, Mahaweli_H_Sown_Rainfed)), 
         
         Kurunegala_Harvested_Major2 = Kurunegala_Harvested_Major + (0.2 * ifelse(is.na(Mahaweli_H_Harvested_Major), 0, Mahaweli_H_Harvested_Major)),
         Kurunegala_Harvested_Minor2 = Kurunegala_Harvested_Minor + (0.2 * ifelse(is.na(Mahaweli_H_Harvested_Minor), 0, Mahaweli_H_Harvested_Minor)),
         Kurunegala_Harvested_Rainfed2 = Kurunegala_Harvested_Rainfed + (0.2 * ifelse(is.na(Mahaweli_H_Harvested_Rainfed), 0, Mahaweli_H_Harvested_Rainfed)),
         
         
         Hambantota_Sown_Major2 = Hambantota_Sown_Major + ((5/7) * ifelse(is.na(Udawalawe_Sown_Major), 0, Udawalawe_Sown_Major)),
         Hambantota_Sown_Minor2 = Hambantota_Sown_Minor + ((5/7) * ifelse(is.na(Udawalawe_Sown_Minor), 0, Udawalawe_Sown_Minor)),
         Hambantota_Sown_Rainfed2 = Hambantota_Sown_Rainfed + ((5/7) * ifelse(is.na(Udawalawe_Sown_Rainfed), 0, Udawalawe_Sown_Rainfed)),
         
         Hambantota_Harvested_Major2 = Hambantota_Harvested_Major + ((5/7) * ifelse(is.na(Udawalawe_Harvested_Major), 0, Udawalawe_Harvested_Major)),
         Hambantota_Harvested_Minor2 = Hambantota_Harvested_Minor + ((5/7) * ifelse(is.na(Udawalawe_Harvested_Minor), 0, Udawalawe_Harvested_Minor)),
         Hambantota_Harvested_Rainfed2 = Hambantota_Harvested_Rainfed + ((5/7) * ifelse(is.na(Udawalawe_Harvested_Rainfed), 0, Udawalawe_Harvested_Rainfed)),
         
         Ratnapura_Sown_Major2 = Ratnapura_Sown_Major + ((1/7) * ifelse(is.na(Udawalawe_Sown_Major), 0, Udawalawe_Sown_Major)),
         Ratnapura_Sown_Minor2 = Ratnapura_Sown_Minor + ((1/7) * ifelse(is.na(Udawalawe_Sown_Minor), 0, Udawalawe_Sown_Minor)),
         Ratnapura_Sown_Rainfed2 = Ratnapura_Sown_Rainfed + ((1/7) * ifelse(is.na(Udawalawe_Sown_Rainfed), 0, Udawalawe_Sown_Rainfed)),
         
         Ratnapura_Harvested_Major2 = Ratnapura_Harvested_Major + ((1/7) * ifelse(is.na(Udawalawe_Harvested_Major), 0, Udawalawe_Harvested_Major)),
         Ratnapura_Harvested_Minor2 = Ratnapura_Harvested_Minor + ((1/7) * ifelse(is.na(Udawalawe_Harvested_Minor), 0, Udawalawe_Harvested_Minor)),
         Ratnapura_Harvested_Rainfed2 = Ratnapura_Harvested_Rainfed + ((1/7) * ifelse(is.na(Udawalawe_Harvested_Rainfed), 0, Udawalawe_Harvested_Rainfed)),
         
         Monaragala_Sown_Major2 = Monaragala_Sown_Major + ((1/7) * ifelse(is.na(Udawalawe_Sown_Major), 0, Udawalawe_Sown_Major)),
         Monaragala_Sown_Minor2 = Monaragala_Sown_Minor + ((1/7) * ifelse(is.na(Udawalawe_Sown_Minor), 0, Udawalawe_Sown_Minor)),
         Monaragala_Sown_Rainfed2 = Monaragala_Sown_Rainfed + ((1/7) * ifelse(is.na(Udawalawe_Sown_Rainfed), 0, Udawalawe_Sown_Rainfed)),
         
         Monaragala_Harvested_Major2 = Monaragala_Harvested_Major + ((1/7) * ifelse(is.na(Udawalawe_Harvested_Major), 0, Udawalawe_Harvested_Major)),
         Monaragala_Harvested_Minor2 = Monaragala_Harvested_Minor + ((1/7) * ifelse(is.na(Udawalawe_Harvested_Minor), 0, Udawalawe_Harvested_Minor)),
         Monaragala_Harvested_Rainfed2 = Monaragala_Harvested_Rainfed + ((1/7) * ifelse(is.na(Udawalawe_Harvested_Rainfed), 0, Udawalawe_Harvested_Rainfed)))

# Yield: need a new weighted average. Yield is by extent harvested. Technically by net, but given I'm using proportions, this doesn't matter. 
data_SHY3 <- data_SHY2 %>%
  mutate(Anuradhapura_Yield_Major2 = ifelse(is.na(Mahaweli_H_Yield_Major), Anuradhapura_Yield_Major, (
    Anuradhapura_Yield_Major * (Anuradhapura_Harvested_Major / (Anuradhapura_Harvested_Major + (0.8 * Mahaweli_H_Harvested_Major))) +
      Mahaweli_H_Yield_Major * ((0.8 * Mahaweli_H_Harvested_Major) / (Anuradhapura_Harvested_Major + (0.8 * Mahaweli_H_Harvested_Major))))),
    
    Anuradhapura_Yield_Minor2 = ifelse(is.na(Mahaweli_H_Yield_Minor), Anuradhapura_Yield_Minor, (
      Anuradhapura_Yield_Minor * (Anuradhapura_Harvested_Minor / (Anuradhapura_Harvested_Minor + (0.8 * Mahaweli_H_Harvested_Minor))) +
        Mahaweli_H_Yield_Minor * ((0.8 * Mahaweli_H_Harvested_Minor) / (Anuradhapura_Harvested_Minor + (0.8 * Mahaweli_H_Harvested_Minor))))),
    
    Anuradhapura_Yield_Rainfed2 = ifelse(is.na(Mahaweli_H_Yield_Rainfed), Anuradhapura_Yield_Rainfed, (
      Anuradhapura_Yield_Rainfed * (Anuradhapura_Harvested_Rainfed / (Anuradhapura_Harvested_Rainfed + (0.8 * Mahaweli_H_Harvested_Rainfed))) +
        Mahaweli_H_Yield_Rainfed * ((0.8 * Mahaweli_H_Harvested_Rainfed) / (Anuradhapura_Harvested_Rainfed + (0.8 * Mahaweli_H_Harvested_Rainfed))))),
    
    
    Kurunegala_Yield_Major2 = ifelse(is.na(Mahaweli_H_Yield_Major), Kurunegala_Yield_Major, (
      Kurunegala_Yield_Major * (Kurunegala_Harvested_Major / (Kurunegala_Harvested_Major + (0.2 * Mahaweli_H_Harvested_Major))) +
        Mahaweli_H_Yield_Major * (0.2 * Mahaweli_H_Harvested_Major) / (Kurunegala_Harvested_Major + (0.2 * Mahaweli_H_Harvested_Major)))),
    
    Kurunegala_Yield_Minor2 = ifelse(is.na(Mahaweli_H_Yield_Minor), Kurunegala_Yield_Minor, (
      Kurunegala_Yield_Minor * (Kurunegala_Harvested_Minor / (Kurunegala_Harvested_Minor + (0.2 * Mahaweli_H_Harvested_Minor))) +
        Mahaweli_H_Yield_Minor * (0.2 * Mahaweli_H_Harvested_Minor) / (Kurunegala_Harvested_Minor + (0.2 * Mahaweli_H_Harvested_Minor)))),
    
    Kurunegala_Yield_Rainfed2 = ifelse(is.na(Mahaweli_H_Yield_Rainfed), Kurunegala_Yield_Rainfed, (
      Kurunegala_Yield_Rainfed * (Kurunegala_Harvested_Rainfed / (Kurunegala_Harvested_Rainfed + (0.2 * Mahaweli_H_Harvested_Rainfed))) +
        Mahaweli_H_Yield_Rainfed * (0.2 * Mahaweli_H_Harvested_Rainfed) / (Kurunegala_Harvested_Rainfed + (0.2 * Mahaweli_H_Harvested_Rainfed)))),
    
    
    Hambantota_Yield_Major2 = ifelse(is.na(Udawalawe_Yield_Major), Hambantota_Yield_Major, (
      Hambantota_Yield_Major * (Hambantota_Harvested_Major / (Hambantota_Harvested_Major + ((5/7) * Udawalawe_Harvested_Major))) +
        Udawalawe_Yield_Major * ((5/7) * Udawalawe_Harvested_Major / (Hambantota_Harvested_Major + ((5/7) * Udawalawe_Harvested_Major))))),
    
    Hambantota_Yield_Minor2 = ifelse(is.na(Udawalawe_Yield_Minor), Hambantota_Yield_Minor, (
      Hambantota_Yield_Minor * (Hambantota_Harvested_Minor / (Hambantota_Harvested_Minor + ((5/7) * Udawalawe_Harvested_Minor))) +
        Udawalawe_Yield_Minor * ((5/7) * Udawalawe_Harvested_Minor / (Hambantota_Harvested_Minor + ((5/7) * Udawalawe_Harvested_Minor))))),
    
    Hambantota_Yield_Rainfed2 = ifelse(is.na(Udawalawe_Yield_Rainfed), Hambantota_Yield_Rainfed, (
      Hambantota_Yield_Rainfed * (Hambantota_Harvested_Rainfed / (Hambantota_Harvested_Rainfed + ((5/7) * Udawalawe_Harvested_Rainfed))) +
        Udawalawe_Yield_Rainfed * ((5/7) * Udawalawe_Harvested_Rainfed / (Hambantota_Harvested_Rainfed + ((5/7) * Udawalawe_Harvested_Rainfed))))),
    
    
    Ratnapura_Yield_Major2 = ifelse(is.na(Udawalawe_Yield_Major), Ratnapura_Yield_Major, (
      Ratnapura_Yield_Major * (Ratnapura_Harvested_Major / (Ratnapura_Harvested_Major + ((1/7) * Udawalawe_Harvested_Major))) +
        Udawalawe_Yield_Major * ((1/7) * Udawalawe_Harvested_Major / (Ratnapura_Harvested_Major + ((1/7) * Udawalawe_Harvested_Major))))),
    
    Ratnapura_Yield_Minor2 = ifelse(is.na(Udawalawe_Yield_Minor), Ratnapura_Yield_Minor, (
      Ratnapura_Yield_Minor * (Ratnapura_Harvested_Minor / (Ratnapura_Harvested_Minor + ((1/7) * Udawalawe_Harvested_Minor))) +
        Udawalawe_Yield_Minor * ((1/7) * Udawalawe_Harvested_Minor / (Ratnapura_Harvested_Minor + ((1/7) * Udawalawe_Harvested_Minor))))),
    
    Ratnapura_Yield_Rainfed2 = ifelse(is.na(Udawalawe_Yield_Rainfed), Ratnapura_Yield_Rainfed, (
      Ratnapura_Yield_Rainfed * (Ratnapura_Harvested_Rainfed / (Ratnapura_Harvested_Rainfed + ((1/7) * Udawalawe_Harvested_Rainfed))) +
        Udawalawe_Yield_Rainfed * ((1/7) * Udawalawe_Harvested_Rainfed / (Ratnapura_Harvested_Rainfed + ((1/7) * Udawalawe_Harvested_Rainfed))))),
    
    
    Monaragala_Yield_Major2 = ifelse(is.na(Udawalawe_Yield_Major), Monaragala_Yield_Major, (
      Monaragala_Yield_Major * (Monaragala_Harvested_Major / (Monaragala_Harvested_Major + ((1/7) * Udawalawe_Harvested_Major))) +
        Udawalawe_Yield_Major * ((1/7) * Udawalawe_Harvested_Major / (Monaragala_Harvested_Major + ((1/7) * Udawalawe_Harvested_Major))))),
    
    Monaragala_Yield_Minor2 = ifelse(is.na(Udawalawe_Yield_Minor), Monaragala_Yield_Minor, (
      Monaragala_Yield_Minor * (Monaragala_Harvested_Minor / (Monaragala_Harvested_Minor + ((1/7) * Udawalawe_Harvested_Minor))) +
        Udawalawe_Yield_Minor * ((1/7) * Udawalawe_Harvested_Minor / (Monaragala_Harvested_Minor + ((1/7) * Udawalawe_Harvested_Minor))))),
    
    Monaragala_Yield_Rainfed2 = ifelse(is.na(Udawalawe_Yield_Rainfed), Monaragala_Yield_Rainfed, (
      Monaragala_Yield_Rainfed * (Monaragala_Harvested_Rainfed / (Monaragala_Harvested_Rainfed + ((1/7) * Udawalawe_Harvested_Rainfed))) +
        Udawalawe_Yield_Rainfed * ((1/7) * Udawalawe_Harvested_Rainfed / (Monaragala_Harvested_Rainfed + ((1/7) * Udawalawe_Harvested_Rainfed))))))

# Removing original columns 
data_SHY4 <- data_SHY3 %>%
  subset(select = -c(Anuradhapura_Sown_Major, Anuradhapura_Sown_Minor, Anuradhapura_Sown_Rainfed,
                     Anuradhapura_Harvested_Major, Anuradhapura_Harvested_Minor, Anuradhapura_Harvested_Rainfed,
                     Anuradhapura_Yield_Major, Anuradhapura_Yield_Minor, Anuradhapura_Yield_Rainfed,
                     
                     Kurunegala_Sown_Major, Kurunegala_Sown_Minor, Kurunegala_Sown_Rainfed,
                     Kurunegala_Harvested_Major, Kurunegala_Harvested_Minor, Kurunegala_Harvested_Rainfed,
                     Kurunegala_Yield_Major, Kurunegala_Yield_Minor, Kurunegala_Yield_Rainfed,
                     
                     Hambantota_Sown_Major, Hambantota_Sown_Minor, Hambantota_Sown_Rainfed,
                     Hambantota_Harvested_Major, Hambantota_Harvested_Minor, Hambantota_Harvested_Rainfed,
                     Hambantota_Yield_Major, Hambantota_Yield_Minor, Hambantota_Yield_Rainfed,
                     
                     Ratnapura_Sown_Major, Ratnapura_Sown_Minor, Ratnapura_Sown_Rainfed,
                     Ratnapura_Harvested_Major, Ratnapura_Harvested_Minor, Ratnapura_Harvested_Rainfed,
                     Ratnapura_Yield_Major, Ratnapura_Yield_Minor, Ratnapura_Yield_Rainfed,
                     
                     Monaragala_Sown_Major, Monaragala_Sown_Minor, Monaragala_Sown_Rainfed,
                     Monaragala_Harvested_Major, Monaragala_Harvested_Minor, Monaragala_Harvested_Rainfed,
                     Monaragala_Yield_Major, Monaragala_Yield_Minor, Monaragala_Yield_Rainfed))

# Renaming new columns with same naming convention as original columns
data_SHY5 <- data_SHY4 %>%
  rename_with(~ gsub("2$", "", .), ends_with("2"))

data_SHY6 <- data_SHY5 %>%
  subset(select = c(1:181, 200:244)) %>%
  pivot_longer(cols = -c(Harvest),
               names_to = c("Region", "SHY", "Irrigation_type"),
               names_sep = "_",
               values_to = "Value")

data_SHY <- data_SHY6 %>%
  mutate_all(~replace_na(.,0))


# 1.3. Functions--------------------------------------------------------------
  ## I use these in various places in my project
  ## Filtering function
  ## Filters data_SHY to show only data from the specified group (maha / yala for 5 year group or ban year), can specify S, H or Y, region and irrigation type. 
  ## Syntax example: filter_data(data_SHY, "maha_5y", "Harvested")

# Define lists of harvest groups
harvest_groups <- list(  
  maha_5y = c("2014/2015_Maha", "2015/2016_Maha", "2016/2017_Maha", "2017/2018_Maha", "2018/2019_Maha"),
  yala_5y = c("2015_Yala", "2016_Yala", "2017_Yala", "2018_Yala", "2019_Yala"),
  maha_ban = c("2021/2022_Maha"),
  yala_ban = c("2021_Yala"),
  yala_post_ban = c("2022_Yala"),
  maha_all = c("2004/2005_Maha", "2005/2006_Maha", "2006/2007_Maha", "2007/2008_Maha", 
               "2008/2009_Maha", "2009/2010_Maha", "2010/2011_Maha", "2011/2012_Maha", 
               "2012/2013_Maha", "2013/2014_Maha", "2014/2015_Maha", "2015/2016_Maha", 
               "2016/2017_Maha", "2017/2018_Maha", "2018/2019_Maha", "2019/2020_Maha", 
               "2020/2021_Maha", "2021/2022_Maha"),
  yala_all = c("2005_Yala", "2006_Yala", "2007_Yala", "2008_Yala", "2009_Yala", 
               "2010_Yala", "2011_Yala", "2012_Yala", "2013_Yala", "2014_Yala", 
               "2015_Yala", "2016_Yala", "2017_Yala", "2018_Yala", "2019_Yala", 
               "2020_Yala", "2021_Yala", "2022_Yala"),
  all = c("2004/2005_Maha", "2005/2006_Maha", "2006/2007_Maha", "2007/2008_Maha", 
          "2008/2009_Maha", "2009/2010_Maha", "2010/2011_Maha", "2011/2012_Maha", 
          "2012/2013_Maha", "2013/2014_Maha", "2014/2015_Maha", "2015/2016_Maha", 
          "2016/2017_Maha", "2017/2018_Maha", "2018/2019_Maha", "2019/2020_Maha", 
          "2020/2021_Maha", "2021/2022_Maha",
          "2005_Yala", "2006_Yala", "2007_Yala", "2008_Yala", "2009_Yala", 
          "2010_Yala", "2011_Yala", "2012_Yala", "2013_Yala", "2014_Yala", 
          "2015_Yala", "2016_Yala", "2017_Yala", "2018_Yala", "2019_Yala", 
          "2020_Yala", "2021_Yala", "2022_Yala")
)

# Same for SHY
SHY_groups <- list(
  Sown = "Sown",
  Harvested = "Harvested",
  Yield = "Yield"
)

# Write function
filter_data <- function(data, harvest_group_name, SHY_name) {    # Defining function with the 3 arguments
  harvests_of_interest <- harvest_groups[[harvest_group_name]]    # Looks up list of harvests in harvest_group_name and assigns it to harvests_of_interest variable; [[ operator used to look up the list of harvests for the given `group_name`
  SHY_of_interest <- SHY_groups[[SHY_name]]    # As above but for SHY
  data_SHY %>%
    filter(Harvest %in% harvests_of_interest,    # Filters `harvest` column to include only the rows where the value is in the harvest_of_interest group
           SHY %in% SHY_of_interest) %>%   # As above but for SHY
    pivot_wider(names_from = "Irrigation_type", values_from = "Value") %>%    # Pivoting wider - need this in later steps (could remove this though? IDK)
    mutate(Total = Major + Minor + Rainfed)    # Calculating total across irrigation types; often need this column
}

filter_data_2 <- function(data, harvest_group_name, SHY_name) {    # Defining function with the 3 arguments
  harvests_of_interest <- harvest_groups[[harvest_group_name]]    # Looks up list of harvests in harvest_group_name and assigns it to harvests_of_interest variable; [[ operator used to look up the list of harvests for the given `group_name`
  SHY_of_interest <- SHY_groups[[SHY_name]]    # As above but for SHY
  data_SHY %>%
    filter(Harvest %in% harvests_of_interest,    # Filters `harvest` column to include only the rows where the value is in the harvest_of_interest group
           SHY %in% SHY_of_interest)
}


# SECTION 2 - YIELDS
# 2.1. Plots and preliminaries -------------------------------------------------
# 2.1.1. Filtering and tidying data --------------------------------------------
GLM_data <- filter_data_2(data_SHY, "all", "Yield") %>%
  separate(`Harvest`, into = c("Year", "Maha_yala"), sep = "_")
GLM_data <- left_join(GLM_data, data_zone_alloc, by = "Region")
GLM_data <- left_join(GLM_data, data_province_alloc, by = "Region")
GLM_data <- GLM_data[GLM_data$Value !=0, ]    # Removing zeros (because they don't mean a yield of 0 but that no harvest happened at all). 

# 2.1.2. Climate zones ---------------------------------------------------------
## There are 3 climate zones - Dry, Intermediate and Wet. 
## TLDR: No difference between Dry and Intermediate: grouped those into 1 zone; those are different to wet zone. 
zone_dif <- lm(Value ~ Zone, GLM_data)    # Making a simple linear model to look at impact of climate zone
display(zone_dif)
anova(zone_dif)    # At least 1 group is significantly different from at least 1 other group
TukeyHSD(aov(zone_dif)) # No significant difference between intermediate and dry zone, but there is between the other combos - somewhat expected
# Density plot
zones1 <- ggplot(GLM_data, aes(x = Value, colour = Zone, fill = Zone)) +
  geom_density(alpha = 0.7) +
  labs(title = "Data density by climate zone",
       y = "Density",
       x = "Yield") +
  scale_fill_manual(values = c("#F3E587", "#6DBD57", "#3385BB")) +
  scale_colour_manual(values = c("black", "black", "black")) +
  theme_fivethirtyeight() +
  scale_y_continuous(labels = label_comma()) +
  theme(axis.title = element_text())
zones1
# Box plot
zones2 <- ggboxplot(data = GLM_data, y = "Value", x = "Zone",
                    fill = "Zone", palette = c("#F3E587", "#6DBD57", "#3385BB"), alpha = 0.7,
                    add = "jitter") +
  labs(title = "Data distribution by climate zone",
       y = "Yield",
       x = "Zone") +
  theme_fivethirtyeight()
zones2

# 2.1.3. Irrigation type -------------------------------------------------------
## There are three irrigation types: Major (big tanks), Minor (small tanks) and Rainfed. 
## TLDR: There's a difference between each. 
irrig_type_dif <- lm(Value ~ Irrigation_type, GLM_data)
display(irrig_type_dif)    # Major average yield = 4404.25; Minor average yield = 4404.25 - 659.47 = 3744.78; Rainfed average yield = 4404.25 - 1056.97 = 3347.28
anova(irrig_type_dif)    # p < 0.05 - at least 1 group is significantly different from at least 1 other group
irrig_type_dif_Tukey <- TukeyHSD(aov(irrig_type_dif)) # all groups significantly different from each other
irrig_type_dif_Tukey
plot(irrig_type_dif_Tukey)
# Density plot
irrigation_type1 <- ggplot(GLM_data, aes(x = Value, colour = Irrigation_type, fill = Irrigation_type)) +
  geom_density(alpha = 0.7) +
  labs(title = "Data density by irrigation type",
       y = "Density",
       x = "Yield") +
  scale_fill_manual(values = c("#F3E587", "#6DBD57", "#3385BB")) +
  scale_colour_manual(values = c("black", "black", "black")) +
  theme_fivethirtyeight() +
  scale_y_continuous(labels = label_comma()) +
  theme(axis.title = element_text())
irrigation_type1
# Box plot
irrigation_type2 <- ggboxplot(data = GLM_data, y = "Value", x = "Irrigation_type",
                              fill = "Irrigation_type", palette = c("#F3E587", "#6DBD57", "#3385BB"), alpha = 0.7,
                              add = "jitter") +
  labs(title = "Data distribution by irrigation type",
       y = "Yield",
       x = "Zone") +
  theme_fivethirtyeight()
irrigation_type2
# 2.1.4. Harvest (Maha vs Yala) -------------------------------------------------
# There are two harvests, Maha and Yala (greater and lesser)
# TLDR: Difference between the two
harvest_dif <- t.test(data = GLM_data, Value ~ Maha_yala, var.equal = T) # Independent samples t-test
harvest_dif    # Maha and Yala harvests significantly different
# Density plot
harvest1 <- ggplot(GLM_data, aes(x = Value, colour = Maha_yala, fill = Maha_yala)) +
  geom_density(alpha = 0.7) +
  labs(title = "Data density by harvest type",
       y = "Density",
       x = "Yield") +
  scale_fill_manual(values = c("#F3E587", "#3385BB")) +
  scale_colour_manual(values = c("black", "black")) +
  theme_fivethirtyeight() +
  scale_y_continuous(labels = label_comma()) +
  theme(axis.title = element_text())
harvest1
# Box plot
harvest2 <- ggboxplot(data = GLM_data, y = "Value", x = "Maha_yala",
                      fill = "Maha_yala", palette = c("#F3E587", "#3385BB"), alpha = 0.7,
                      add = "jitter") +
  labs(title = "Data distribution by harvest type",
       y = "Yield",
       x = "Harvest") +
  theme_fivethirtyeight()
harvest2

# 2.2 Ban stages ---------------------------------------------------------------
# 2.2.1. Ban stages preliminaries -------------------------------------------
# Mutating the data to pick out the ban harvests. 
GLM_data2 <- GLM_data %>% mutate(Ban1 = if_else(Year %in% c("2022", "2021/2022", "2021"), "Ban", "No_ban"))    # Adds ban variable encompassing whole ban (2021-22)
GLM_data2 <- GLM_data %>% mutate(Ban2 = if_else(Year %in% c("2022", "2021/2022"), "Ban", "No_ban"))    # Adds ban variable encompassing period when ban was felt (second half of 2021, 2022)
GLM_data2 <- GLM_data %>% mutate(Ban3 = ifelse(Year == 2021, "Ban_stage_1",    # Adds a ban variable with three levels - ban, ban stage 1 and ban stage 2      
                                               ifelse(Year %in% c("2021/2022", "2022"), "Ban_stage_2", "No_ban")))
## I made two ban stages, stage 1 (first Yala ban harvest) and stage 2 (the other two harvests)
## Ban stage 1 is bimodal! But not significantly different from no ban. Will look into it, then eliminate. 
ban_stages <- lm(Value ~ Ban3, GLM_data2)
anova(ban_stages)
summary(ban_stages)
TukeyHSD(aov(Value ~ Ban3, data = GLM_data2))
# Density plot
ban_stages1 <- ggplot(GLM_data2, aes(x = Value, colour = Ban3, fill = Ban3)) +
  geom_density(alpha = 0.7) +
  labs(title = "Data density by ban stage",
       y = "Density",
       x = "Yield") +
  scale_fill_manual(values = c("#F3E587", "#6DBD57", "#3385BB")) +
  scale_colour_manual(values = c("black", "black", "black")) +
  theme_fivethirtyeight() +
  scale_y_continuous(labels = label_comma()) +
  theme(axis.title = element_text())
ban_stages1
# Box plot
ban_stages2 <- ggboxplot(data = GLM_data2, y = "Value", x = "Ban3",
                         fill = "Ban3", palette = c("#F3E587", "#6DBD57", "#3385BB"), alpha = 0.7,
                         add = "jitter") +
  labs(title = "Data distribution by ban stage",
       y = "Yield",
       x = "Ban stage") +
  theme_fivethirtyeight() +
  theme(axis.title =element_text())
ban_stages2

# 2.2.2. Stage 1 ban -------------------------------------------------------- 
# Looking further the first ban harvest:
# Climate zone is the key predictor, though irrigation type plays a role. 
GLM_data2 <- GLM_data2 %>% mutate(New_zone = if_else(Zone %in% c("Dry", "Intermediate"), "Dry_intermediate", "Wet"))     # Grouping dry and intermediate zones
ban_stage_1_data <- filter(GLM_data2, Year == "2021")
LM_ban_stage_1 <- lm(Value ~ New_zone + Irrigation_type,
                     data = ban_stage_1_data)
anova(LM_ban_stage_1)
summary(LM_ban_stage_1)
TukeyHSD(aov(LM_ban_stage_1))
plot(LM_ban_stage_1)
# Density plot showing zones
ban_stage_1_plot_1 <- ggplot(ban_stage_1_data, aes(x = Value, colour = New_zone, fill = New_zone)) +
  geom_density(alpha = 0.7) +
  scale_fill_manual(values = c("#F3E587", "#3385BB")) +
  scale_colour_manual(values = c("black", "black")) +
  theme_fivethirtyeight() +
  scale_y_continuous(labels = label_comma()) +
  theme(axis.title = element_text())
ban_stage_1_plot_1
# Density plot showing irrigation types
ban_stage_1_plot_2 <- ggplot(ban_stage_1_data, aes(x = Value, colour = Irrigation_type, fill = Irrigation_type)) +
  geom_density(alpha = 0.7) +
  labs(title = "Ban stage 1 data density by irrigation type",
       y = "Density",
       x = "Yield") +
  scale_fill_manual(values = c("#F3E587", "#6DBD57", "#3385BB")) +
  scale_colour_manual(values = c("black", "black", "black")) +
  theme_fivethirtyeight() +
  scale_y_continuous(labels = label_comma()) +
  theme(axis.title = element_text()) 
ban_stage_1_plot_2
# Interaction plot
ban_stage_1_plot <- interaction.plot(ban_stage_1_data$New_zone, ban_stage_1_data$Irrigation_type,
                                     response = predict(LM_ban_stage_1),
                                     ylim = range(ban_stage_1_data$Value),
                                     main = "Exploring Ban Stage 1 (Yala 2021) Data",
                                     xlab = "Zone",
                                     ylab = "Predicted yield",
                                     trace.label = "Irrigation type",
                                     col = c("#F3E587", "#6DBD57", "#3385BB"),
                                     lwd = 2)
# 2.3. Assumptions -------------------------------------------------------------
# 2.3.1 Assumptions explore-----------------------------------------------------
# Plot distribution
# Plotting histogram of all data
describe(GLM_data)
glm_data_plot <- ggplot(GLM_data, aes(x = Value)) +
  geom_histogram(alpha = 0.7, fill = "#3385bb") +
  labs(title = "Data distribution",
       y = "Count",
       x = "Yield") +
  theme_fivethirtyeight() +
  theme(axis.title = element_text())
glm_data_plot
# Looking at normality of residuals and homogeneity of variances assumptions
# Zone
res_GLM_data_zone <- aov(Value ~ Zone, data = GLM_data)
hist_zone <- hist(res_GLM_data_zone$residuals, main = "Histogram for zone residuals", ylab = "Frequency", xlab = "Residuals")
QQ_zone <- qqPlot(res_GLM_data_zone$residuals, id = F, main = "QQ plot for zone residuals", ylab = "Residuals", xlab = "Norm quantiles") 
leveneTest(Value ~ Zone, data = GLM_data)   # Zone
# Irrigation type
res_GLM_data_irrigation_type <- aov(Value ~ Irrigation_type, data = GLM_data)
hist_irrigation_type <- hist(res_GLM_data_irrigation_type$residuals, main = "Histogram for irrigation type residuals", ylab = "Frequency", xlab = "Residuals")
QQ_irrigation_type <- qqPlot(res_GLM_data_irrigation_type$residuals, id = F, main = "QQ plot for irrigation type residuals", ylab = "Residuals", xlab = "Norm quantiles") 
leveneTest(Value ~ Irrigation_type, data = GLM_data)   # Irrigation type
# Maha vs yala
res_GLM_data_harvest <- aov(Value ~ Maha_yala, data = GLM_data)
hist_harvest <- hist(res_GLM_data_harvest$residuals, main = "Histogram for harvest residuals", ylab = "Frequency", xlab = "Residuals")
QQ_harvest <- qqPlot(res_GLM_data_harvest$residuals, id = F, main = "QQ plot for harvest residuals", ylab = "Residuals", xlab = "Norm quantiles") 
leveneTest(Value ~ Maha_yala, data = GLM_data)   # Harvest
# Check with QQ plot
ggplot(GLM_data, aes(sample = Value)) +
  geom_qq() +
  geom_qq_line(colour = "red") 

# 2.4. Model -------------------------------------------------------------------
# 2.4.1. Changes to data ---------------------------------------------------------
# First, I need to make some changes to the data. These include:
### Changing the flood variable (to then decide what grouping to use):
## Whole country = flood in 2010/2011
## Regions with more than 1%; 5%; 10% area flooded = flood in 2010/2011 (from FAS report for 2011)
## Eyeballed from graph - regions where yield decreased
### Changing the ban variable (to then decide what grouping to use):
## Ban = all seasons where there was a ban
## Ban = only seasons when ban is obviously being felt (i.e. not the first yala harvest)
## Ban = all seasons, but splitting out the first yala harvest as a separate category
### Joining Dry and Intermediate zones into one (because they're not statistically significantly different from each other)
# Making changes to data:
GLM_data <- GLM_data %>% mutate(Flood = if_else(Year == "2010/2011", "Flood", "No_flood"))    # Old flood dummy variable
GLM_data <- GLM_data %>% mutate(New_zone = if_else(Zone %in% c("Dry", "Intermediate"), "Dry_intermediate", "Wet"))     # Grouping dry and intermediate zones
GLM_data <- GLM_data %>% mutate(Ban = if_else(Year %in% c("2022", "2021/2022"), "Ban", "No_ban"))    # Adds ban variable encompassing whole ban (2021-22)
GLM_data <- GLM_data %>% filter(Year != "2021")    # This removes the 2021 Yala data (as discussed with EJ and Mike - transient effects of ban)

# 2.5. LM models ---------------------------------------------------------------
# 2.5.1. Minimal Adequate Model approach ---------------------------------------
# Following stats notes from 2nd year and this doc: https://s3-eu-west-1.amazonaws.com/s3-euw1-ap-pe-ws4-cws-documents.ri-prod/9781138024571/chapters/ch10/3__Using_R_to_Finding_a_Minimal_Model.JLH.pdf#:~:text=Using%C2%A0R%C2%A0to%C2%A0Find%C2%A0a%C2%A0Minimal%C2%A0Model%C2%A0for%C2%A0a%C2%A0Factorial%C2%A0ANOVA%20What%20I%20will%20demonstrate%20in%20this%20section,in%20Section%207.4.5%20in%20the%20book%20on%20regression%2C
# I go from the full model, through stepwise deletion of interaction terms to the MAM
## I remove the least significant, highest order terms first, then compare the two models using anova(mod1, mod2)
## If there is no statistically significant difference between the models, then we prefer the new model because it's simpler
## Then repeat
full <- lm(Value ~ Ban + New_zone + Irrigation_type + Maha_yala + Flood +    # 1 way interactions
             Ban*New_zone + Ban*Irrigation_type + Ban*Maha_yala + New_zone*Irrigation_type + New_zone*Maha_yala + New_zone*Flood + Irrigation_type*Maha_yala + Irrigation_type*Flood +    # 2 way interactions
             Ban*New_zone*Irrigation_type + Ban*New_zone*Maha_yala + Ban*Irrigation_type*Maha_yala + New_zone*Irrigation_type*Maha_yala + New_zone*Irrigation_type*Flood +     # 3 way interactions
             Ban*New_zone*Irrigation_type*Maha_yala    # 4 way interaction
           , data = GLM_data)
anova(full)

# First, removing 4 way interaction
maximal1 <- lm(Value ~ Ban + New_zone + Irrigation_type + Maha_yala + Flood +    # 1 way interactions
                 Ban*New_zone + Ban*Irrigation_type + Ban*Maha_yala + New_zone*Irrigation_type + New_zone*Maha_yala + New_zone*Flood + Irrigation_type*Maha_yala + Irrigation_type*Flood +    # 2 way interactions
                 Ban*New_zone*Irrigation_type + Ban*New_zone*Maha_yala + Ban*Irrigation_type*Maha_yala + New_zone*Irrigation_type*Maha_yala + New_zone*Irrigation_type*Flood    # 3 way interactions
               , data = GLM_data)

anova(full, maximal1)    # No statistically significant difference 
anova(maximal1)    # Looking for next term to remove

# Then, removing Ban:Irrigation_type:Maha_yala
maximal2 <- lm(Value ~ Ban + New_zone + Irrigation_type + Maha_yala + Flood +    # 1 way interactions
                 Ban*New_zone + Ban*Irrigation_type + Ban*Maha_yala + New_zone*Irrigation_type + New_zone*Maha_yala + New_zone*Flood + Irrigation_type*Maha_yala + Irrigation_type*Flood +    # 2 way interactions
                 Ban*New_zone*Irrigation_type + Ban*New_zone*Maha_yala + New_zone:Irrigation_type:Maha_yala + New_zone*Irrigation_type*Flood    # 3 way interactions
               , data = GLM_data)

anova(maximal1, maximal2)    # No statistically significant difference
anova(maximal2)    # Looking for next term to remove

# Then, removing New_zone:Irrigation_type:Maha_yala
maximal3 <- lm(Value ~ Ban + New_zone + Irrigation_type + Maha_yala + Flood +    # 1 way interactions
                 Ban*New_zone + Ban*Irrigation_type + Ban*Maha_yala + New_zone*Irrigation_type + New_zone*Maha_yala + New_zone*Flood + Irrigation_type*Maha_yala + Irrigation_type*Flood +    # 2 way interactions
                 Ban*New_zone*Irrigation_type + Ban*New_zone*Maha_yala + New_zone:Irrigation_type:Flood    # 3 way interactions
               , data = GLM_data)

anova(maximal2, maximal3)    # No statistically significant difference
anova(maximal3)    # Looking for next term to remove

# Then, removing New_zone:Irrigation_type:Flood 
maximal4 <- lm(Value ~ Ban + New_zone + Irrigation_type + Maha_yala + Flood +    # 1 way interactions
                 Ban*New_zone + Ban*Irrigation_type + Ban*Maha_yala + New_zone*Irrigation_type + New_zone*Maha_yala + New_zone*Flood + Irrigation_type*Maha_yala + Irrigation_type*Flood +    # 2 way interactions
                 Ban*New_zone*Irrigation_type + Ban*New_zone*Maha_yala    # 3 way interactions
               , data = GLM_data)

anova(maximal3, maximal4)    # No statistically significant difference
anova(maximal4)    # Looking for next term to remove

# Then, removing Ban:New_zone:Irrigation_type 
maximal5 <- lm(Value ~ Ban + New_zone + Irrigation_type + Maha_yala + Flood +    # 1 way interactions
                 Ban*New_zone + Ban*Irrigation_type + Ban*Maha_yala + New_zone*Irrigation_type + New_zone*Maha_yala + New_zone*Flood + Irrigation_type*Maha_yala + Irrigation_type*Flood +    # 2 way interactions
                 Ban*New_zone*Maha_yala    # 3 way interactions
               , data = GLM_data)

anova(maximal4, maximal5)    # No statistically significant difference
anova(maximal5)    # Looking for next term to remove

# Then, removing Ban:New_zone:Maha_yala
maximal6 <- lm(Value ~ Ban + New_zone + Irrigation_type + Maha_yala + Flood +    # 1 way interactions
                 Ban*New_zone + Ban*Irrigation_type + Ban*Maha_yala + New_zone*Irrigation_type + New_zone*Maha_yala + New_zone*Flood + Irrigation_type*Maha_yala + Irrigation_type*Flood    # 2 way interactions
               , data = GLM_data)

anova(maximal5, maximal6)    # No statistically significant difference
anova(maximal6)    # Looking for next term to remove

# Then, removing Irrigation_type:Flood
maximal7 <- lm(Value ~ Ban + New_zone + Irrigation_type + Maha_yala + Flood +    # 1 way interactions
                 Ban*New_zone + Ban*Irrigation_type + Ban*Maha_yala + New_zone*Irrigation_type + New_zone*Maha_yala + New_zone*Flood + Irrigation_type*Maha_yala    # 2 way interactions
               , data = GLM_data)

anova(maximal6, maximal7)    # No statistically significant difference
anova(maximal7)    # Looking for next term to remove

# Then, removing Irrigation_type:Maha_yala
maximal8 <- lm(Value ~ Ban + New_zone + Irrigation_type + Maha_yala + Flood +    # 1 way interactions
                 Ban*New_zone + Ban*Irrigation_type + Ban*Maha_yala + New_zone*Irrigation_type + New_zone*Maha_yala + New_zone*Flood    # 2 way interactions
               , data = GLM_data)

anova(maximal7, maximal8)    # No statistically significant difference
anova(maximal8)     # Looking for next term to remove

# Then, removing Ban:Irrigation_type
maximal9 <- lm(Value ~ Ban + New_zone + Irrigation_type + Maha_yala + Flood +    # 1 way interactions
                 Ban*New_zone + Ban*Maha_yala + New_zone*Irrigation_type + New_zone*Maha_yala + New_zone*Flood    # 2 way interactions
               , data = GLM_data)

anova(maximal8, maximal9)    # No statistically significant difference
anova(maximal9)    # all terms are signficant. 
summary(maximal9)    

# Outputs for write-up: changing reference levels
GLM_data_wu <- GLM_data
GLM_data_wu$Ban <- factor(GLM_data$Ban, levels = c("No_ban", "Ban"))
GLM_data_wu$Flood <- factor(GLM_data$Flood, levels = c("No_flood", "Flood"))

GLM_data_wu$Ban <- relevel(GLM_data_wu$Ban, ref = "No_ban") 
GLM_data_wu$Flood <- relevel(GLM_data_wu$Flood, ref = "No_flood")

# Fit model with new reference levels
maximal9_wu <- lm(Value ~ Ban + New_zone + Irrigation_type + Maha_yala + Flood + 
                    Ban*New_zone + Ban*Maha_yala + New_zone*Irrigation_type + 
                    New_zone*Maha_yala + New_zone*Flood, data = GLM_data_wu)
summary(maximal9_wu)

# 2.5.2. Using bootStepAIC package to compare its MAM. 
# There is a function called boot.stepAIC() from the bootStepAIC package that can do this for me 
boot.stepAIC(full, data = GLM_data)    # Note this takes some time
# It kept two more terms, including a three way interaction. Not going to use this (it's mentioned in the document linked above, but says to take outputs with a pinch of salt). 
# 2.5.3. Final model-related steps ---------------------------------------------
# check vs null
null <- lm(Value ~ 1, data = GLM_data)
anova(null, maximal9)    # My model does a better job than the null (fortunately!)
# Plotting the outputs
par(mfrow = c(2,2))
plot(maximal9)












# 2.6.1. Yield graph -----------------------------------------------------------
# Editing data
Ordered_ban <- c("No_ban", "Ban")
Model_outputs_graph <- Model_outputs_tidy %>%
  mutate(Ban = factor(Ban, levels = Ordered_ban))
Model_outputs_graph_pc_decrease <- Model_outputs_tidy %>%
  pivot_wider(names_from = Ban, values_from = c(Predicted_yield, Predicted_yield_se)) %>%
  mutate(Abs_loss = Predicted_yield_Ban - Predicted_yield_No_ban,
         PC_decrease = Abs_loss / Predicted_yield_No_ban,
         Abs_loss_se = add_subt_se(Predicted_yield_se_Ban, Predicted_yield_se_No_ban),
         PC_decrease_se = ratio_se(Abs_loss, Predicted_yield_No_ban, Abs_loss_se, Predicted_yield_se_No_ban))
# Making graph
line_graph <-
  ggplot(Model_outputs_graph, aes(x = Ban, y = Predicted_yield, color = Irrigation_type)) +
  geom_errorbar(aes(ymin = Predicted_yield - Predicted_yield_se,
                    ymax = Predicted_yield + Predicted_yield_se, width = 0.1), colour = "black", alpha = 0.8) +
  geom_point(size = 3) +
  geom_line(aes(group = Irrigation_type), size = 1.25) +
  scale_color_manual(values = c("#fde725", "#21918c", "#440154")) +
  scale_x_discrete(labels = c("No ban", "Ban")) +
  facet_grid(Maha_yala ~ New_zone, 
             labeller = as_labeller(c("Dry_intermediate" = "Dry & \nIntermediate", "Wet" = "Wet", 
                                      "Maha" = "Maha", "Yala" = "Yala"))) +
  labs(x = "Agrochemical ban status",
       y = "Predicted \nyield (kg/ha)",
       title = "Factorial ANOVA yield outputs before and after the ban, by cultivation season, \nclimate zone and irrigation type") +
  theme(
    plot.title = element_blank(),
    axis.title = element_text(size = 20),
    axis.title.y = element_text(angle = 0, vjust = 0.5, hjust = 0),
    axis.text = element_text(size = 17, colour = "black"),
    legend.text = element_text(size = 15),
    legend.title = element_text(size = 17),
    legend.position = "bottom",
    legend.key = element_blank(),
    strip.background = element_rect(fill = "lightgrey", color = "black"),  # Set the background color of the strip to white
    panel.background = element_rect(fill = "white", color = "white"),  # Set the background color of the panels to white with a white border
    panel.border = element_rect(color = "black", fill = NA),  # Add a black border around the panels
    axis.line = element_line(color = "black"),  # Set the color of the axes to black
    panel.grid.major = element_blank(),  # Remove major grid lines
    panel.grid.minor = element_blank(),  # Remove minor grid lines
    strip.text.x = element_text(size = 17),
    strip.text.y = element_text(size = unit(17, "pt"), angle = 0, hjust = 0.5),
    panel.spacing = unit(1, "lines"),
    plot.margin = margin(50, 100, 10, 10)) +
  guides(color = guide_legend(title = "Irrigation type", title.position = "top", title.hjust = 0.5))

line_graph2 <- line_graph +
  geom_text(data = Model_outputs_graph_pc_decrease,
            aes(label = paste0(sprintf("%.1f", PC_decrease * 100), "%"), x = 2.1, y = Predicted_yield_Ban),
            hjust = 0, vjust = 0.5, color = "grey40", size = 4)
library(grid)
y_title_grob2 <- textGrob("Climate \nzone", x = unit(0.9, "npc"), y = unit(0.52, "npc"), just = "left", gp = gpar(fontsize = 19, lineheight = 0.8), rot = 0, vp = viewport())
x_title_grob <- textGrob("Cultivation season", x = unit(0.5, "npc"), y = unit(0.95, "npc"), just = "centre", gp = gpar(fontsize = 19, rot = 0, vp = viewport()))
print(line_graph2)
grid::grid.draw(y_title_grob2)
grid::grid.draw(x_title_grob)
# SECTION 3 - PADDY PRODUCTION --------------------------------------------------
# 3: Baseline production -------------------------------------------------------
  ## I need the pre-ban baseline production to anchor the model in a value. 
# 3.1: Working out net production by region by irrigation type: ----------------
  # I don't trust the DCS production values - there are some (quite big) discrepancies.
  # Hence, I recalculated the production values. 
  # This is a bit complex:
    ## production = average yield per net ha * ha
    ## but my extent harvested data (which is by region by irrigation type) is by gross ha, not net ha
    ## and this can have a big impact on production values
      ### BUT from the Crop Cutting Survey Document (2022), I've worked out that they gross --> net comes from multiplying by a correction factor (CF)
      ### So production by irrigation type is approx. equal to (gross extent harvested * CF * average yield) 
      ### Gross extent harvested and average yield values are specific to each irrigation type for each region; CF for region. 
# 3.1.1. Calculating correction factor -----------------------------------------
## Gross area harvested - first, I worked out total gross area harvested and tidied the data.
Gross_harvested_total <-
  data_SHY %>%
  filter(SHY == "Harvested") %>%
  pivot_wider(names_from = "Irrigation_type", values_from = "Value") %>%
  mutate(Gross_harvested_total = Major + Minor + Rainfed)
## Net area harvested data - then, I tidied the net area harvested data.
Net_harvested_total <-
  data_HP %>%
  subset(select = c(Harvest, Region, Net_harvested)) %>%
  rename(Net_harvested_total = Net_harvested)
## Joining the net and gross area harvested into the same tibble. 
Correction_factor <- left_join(Gross_harvested_total, Net_harvested_total, by = c("Harvest", "Region"))
Correction_factor <- subset(Correction_factor, select = c(Harvest, Region, Gross_harvested_total, Net_harvested_total))
## Working out ratio (correction factor) between gross and net area harvested per region per harvest. 
Correction_factor <- mutate(Correction_factor, Correction_factor = Net_harvested_total / Gross_harvested_total)
Correction_factor <- subset(Correction_factor, select = c(Harvest, Region, Correction_factor))
## Pivot wider to get desired structure - need Regions as columns
Correction_factor_wide <- Correction_factor %>%
  pivot_wider(
    names_from = "Region",
    values_from = "Correction_factor")
## Renaming region columns so they have _correction_factor at the end:
colnames(Correction_factor_wide)[c(2:28)] <- paste(colnames(Correction_factor_wide)[c(2:28)], 'correction_factor', sep = '_') 
# Going back to data SHY and extracting Harvest and Yield; then pivoting wider:
# Filtering for the "Harvested" and "Yield" rows
Production_HY <- data_SHY %>%
  filter(SHY %in% c("Harvested", "Yield"))
## Pivoting wider to get the desired structure
Production_HY_wide <- Production_HY %>%
  pivot_wider(
    names_from = c("Region", "SHY"),
    values_from = "Value",
    names_prefix = "", # No prefix for column names
    names_sep = "_", # Separator between Region and SHY
    values_fill = NA # Fill missing values with NA
  )
# 3.1.2. Applying correction factor --------------------------------------------
## Joining Production_HY_side and Correction_factor_wide
Production_HY_CF <- left_join(Production_HY_wide, Correction_factor_wide, by = "Harvest")
## Multiplying out to get net production by region by irrigation type (Gross area * Correction factor * yield) - could have done this much faster!
Production_HY_CF <- Production_HY_CF %>%
  mutate(Colombo_Net_Production = Colombo_Harvested * Colombo_Yield * Colombo_correction_factor,
         Gampaha_Net_Production = Gampaha_Harvested * Gampaha_Yield * Gampaha_correction_factor,
         Kalutara_Net_Production = Kalutara_Harvested * Kalutara_Yield * Kalutara_correction_factor,
         Kandy_Net_Production = Kandy_Harvested * Kandy_Yield * Kandy_correction_factor,
         Matale_Net_Production = Matale_Harvested * Matale_Yield * Matale_correction_factor,
         Nuwaraeliya_Net_Production = Nuwaraeliya_Harvested * Nuwaraeliya_Yield * Nuwaraeliya_correction_factor,
         Galle_Net_Production = Galle_Harvested * Galle_Yield * Galle_correction_factor,
         Matara_Net_Production = Matara_Harvested * Matara_Yield * Matara_correction_factor,
         Hambantota_Net_Production = Hambantota_Harvested * Hambantota_Yield * Hambantota_correction_factor,
         Jaffna_Net_Production = Jaffna_Harvested * Jaffna_Yield * Jaffna_correction_factor,
         Mannar_Net_Production = Mannar_Harvested * Mannar_Yield * Mannar_correction_factor,
         Vavuniya_Net_Production = Vavuniya_Harvested * Vavuniya_Yield * Vavuniya_correction_factor,
         Mulativu_Net_Production = Mulativu_Harvested * Mulativu_Yield * Mulativu_correction_factor,
         Killinochchi_Net_Production = Killinochchi_Harvested * Killinochchi_Yield * Killinochchi_correction_factor,
         Batticaloa_Net_Production = Batticaloa_Harvested * Batticaloa_Yield * Batticaloa_correction_factor,
         Ampara_Net_Production = Ampara_Harvested * Ampara_Yield * Ampara_correction_factor,
         Trincomalee_Net_Production = Trincomalee_Harvested * Trincomalee_Yield * Trincomalee_correction_factor,
         Kurunegala_Net_Production = Kurunegala_Harvested * Kurunegala_Yield * Kurunegala_correction_factor,
         Puttalam_Net_Production = Puttalam_Harvested * Puttalam_Yield * Puttalam_correction_factor,
         Anuradhapura_Net_Production = Anuradhapura_Harvested * Anuradhapura_Yield * Anuradhapura_correction_factor,
         Polonnaruwa_Net_Production = Polonnaruwa_Harvested * Polonnaruwa_Yield * Polonnaruwa_correction_factor,
         Badulla_Net_Production = Badulla_Harvested * Badulla_Yield * Badulla_correction_factor,
         Monaragala_Net_Production = Monaragala_Harvested * Monaragala_Yield * Monaragala_correction_factor,
         Ratnapura_Net_Production = Ratnapura_Harvested * Ratnapura_Yield * Ratnapura_correction_factor,
         Kegalle_Net_Production = Kegalle_Harvested * Kegalle_Yield * Kegalle_correction_factor)
## Filtering out production
Production_net_calc <- Production_HY_CF %>%
  subset(select = c(1:2, 78:102))    # Selecting columns I need 
## Replacing NAs and NaNs with 0.
Production_net_calc <- Production_net_calc %>% replace(is.na(.), 0)    
# 3.1.3. Calculating baseline average values (5 year and total) ----------------
## First, I need to pivot the dataset so it's in a long format (helps later)
Production_net_calc_long2 <- pivot_longer(
  Production_net_calc,
  cols = c(3:27),
  names_to = "Region",
  values_to = "Net_production_calc") 
## Second, I tidy the data, exclude post-ban values, pivot it again.
Production_net_calc_long2$Region <- str_remove(Production_net_calc_long2$Region, "_Net_Production")    # Tidying Region data - removing _Net_Production 
Production_net_calc_long2 <- subset(Production_net_calc_long2, !(Harvest %in% c("2022_Yala", "2021/2022_Maha", "2021_Yala")))    # Removes post-ban rows. 
Production_net_calc_long2 <- Production_net_calc_long2 %>%
  separate(`Harvest`, into = c("Year", "Maha_yala"), sep = "_") %>%
  pivot_wider(names_from = "Year",
              values_from = "Net_production_calc") 
## Third, I work out the average production values (sum all the rows first, then divide by number of harvests for Maha and Yala separately)
### Have done it twice, once for all years, and once for last 5 years before the ban. 
Production_net_calc_long2$Total_prod <- apply(Production_net_calc_long2[, 4:36], 1, sum, na.rm = TRUE)    # This sums all the rows with production values, removing the NAs
Production_net_calc_long2 <- mutate(Production_net_calc_long2, 
                                    Mean_prod_total = if_else(Maha_yala == "Maha", Total_prod / 17, Total_prod/16))    # This calculates the mean, taking the number of harvests for maha and yala into account (maha has one more than yala)
Production_net_calc_long2$five_yr_prod <- apply(Production_net_calc_long2[, 4:13], 1, sum, na.rm = TRUE)    # This sums all the rows with production values, removing the NAs
Production_net_calc_long2 <- mutate(Production_net_calc_long2, 
                                    Mean_prod_5y = five_yr_prod / 5)    # This calculates the mean, taking the number of harvests for maha and yala into account (maha has one more than yala)
## Fourth, calculating SEM
Production_net_calc_long2 <- Production_net_calc_long2 %>%
  rowwise() %>%
  mutate(SEM = std.error(c_across(4:13), na.rm = TRUE)) 
Production_net_calc_long3 <- Production_net_calc_long2 %>%
  mutate(Mean_prod_plus_sem = Mean_prod_5y + SEM,
         Mean_prod_minus_sem = Mean_prod_5y - SEM)
## Plotting SEM
Production_net_calc_long_SEM_graph <- Production_net_calc_long3 %>%
  unite(Region_irrigation, Region, Irrigation_type, sep = "_") 
ggplot(Production_net_calc_long3) +
  geom_bar(aes(x = Region, y = Mean_prod_5y), stat = 'identity', fill = 'steelblue') +
  geom_errorbar(aes(x = Region, ymin = Mean_prod_5y - SEM, ymax = Mean_prod_5y + SEM), width = 0.4) +
  labs(title = "Mean production (5 year baseline) and standard error of the mean (SEM)",
       x = "Region",
       y = "Production") +
  theme_fivethirtyeight() +
  theme(axis.title = element_text(),
        axis.text.x = element_text(angle = 45, hjust = 1, size = 7)) +
  facet_wrap(vars(Maha_yala, Irrigation_type))
## 3.1.4. Looking at difference between 5YA and baseline -----------------------
### First, need to play with the data so it's in the right format for ggplot:
Production_graph <- Production_net_calc_long3 %>%
  mutate(Mean_difference = Mean_prod_5y - Mean_prod_total) %>%
  subset(select = c(1:3, 44)) %>%
  pivot_longer(cols = "Mean_difference",
               names_to = "Mean_difference",
               values_to = "Value")
Production_graph <- left_join(Production_graph, data_zone_alloc, by = "Region")
### Second, make the graph. 
### Box plot shows production in 5y than baseline. 
## Most medians either very near or above the line. 
## Dry zone production has increased, other zones more stable.
ggplot(Production_graph, aes(x = Region, y = Value, colour = Zone)) +
  geom_boxplot() +
  labs(title = "5 year baseline values tend to be higher / same as 16 or 17 year baseline",
       subtitle = "Above line y=0 represents higher 5 year baseline value") +
  theme_fivethirtyeight() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))








# SECTION 4 - PADDY LAND -------------------------------------------------------
  # First, I prepare the Production data
  # Second, I prepare the Yield data 
  # Third, I join Production and Yield data
  # Fourth, I use Production and Yield data to calculate land required.
  # Fifth, I look at land increase by region
# 4.1.1. Functions -----------------------------------------------------------------
  # These functions apply propagation rules for standard error
product_se <- function(x, y, x_se, y_se) {
  se <- x * y * sqrt(((x_se / x)^2) + ((y_se / y)^2))
  return(se)
}
ratio_se <- function(x, y, x_se, y_se) {
  se <- x / y * sqrt((x_se / x)^2 + (y_se / y)^2)
  return(se)
}
add_subt_se <- function(x_se, y_se) {
  se <- sqrt((x_se)^2 + (y_se)^2)
  return(se)
}
# 4.1.2. Production data -----------------------------------------------------------
  # Cleaning production 5 year baseline data from Production data script:
  # This is 5 year mean and mean =/-SEM by harvest (maha vs yala), region, irrigation type
Production_5y_bl <- Production_net_calc_long2 %>%
  subset(select = c(1:3, 40, 41))     # Selecting columns: harvest, irrigation type and region, 5y mean and 5y mean +/-SEM
Production_5y_bl <- left_join(Production_5y_bl, data_zone_alloc, by = "Region")    # joining it with Zone data
Production_5y_bl <- Production_5y_bl %>% mutate(New_zone = if_else(Zone %in% c("Dry", "Intermediate"), "Dry_intermediate", "Wet"))     # Grouping dry and intermediate zones

Production_5y_bl <- Production_5y_bl %>%
  subset(select = c(1, 3, 2, 7, 4, 5)) %>%    # Rearranging columns and removing Zone column (just keep New_zone)
  rename("Mean_prod_5y_sem" = "SEM")    # Clarifying column names
# 4.2.1. Yield data ----------------------------------------------------------------
  # Taking yield model outputs (before and after ban, directly from Stats script) 
  # Combos is a data frame with all the combinations that can come out of the model (I then remove combinations with Flood)
  # Then I clean it and prepare it to be joined with my model predictions. 
Combos <- data.frame(
  Maha_yala = factor(c("Maha","Maha","Maha","Maha","Maha","Maha","Maha","Maha","Maha","Maha","Maha","Maha","Maha","Maha","Maha","Maha","Maha","Maha","Yala","Yala","Yala","Yala","Yala","Yala","Yala","Yala","Yala","Yala","Yala","Yala")),
  New_zone = factor(c("Dry_intermediate","Dry_intermediate","Dry_intermediate","Dry_intermediate","Dry_intermediate","Dry_intermediate","Dry_intermediate","Dry_intermediate","Dry_intermediate","Wet","Wet","Wet","Wet","Wet","Wet","Wet","Wet","Wet","Dry_intermediate","Dry_intermediate","Dry_intermediate","Dry_intermediate","Dry_intermediate","Dry_intermediate","Wet","Wet","Wet","Wet","Wet","Wet")),
  Irrigation_type = factor(c("Major","Minor","Rainfed","Major","Minor","Rainfed","Major","Minor","Rainfed","Major","Minor","Rainfed","Major","Minor","Rainfed","Major","Minor","Rainfed","Major","Minor","Rainfed","Major","Minor","Rainfed","Major","Minor","Rainfed","Major","Minor","Rainfed")),
  Flood = factor(c("No_flood","No_flood","No_flood","No_flood","No_flood","No_flood","Flood","Flood","Flood","No_flood","No_flood","No_flood","No_flood","No_flood","No_flood","Flood","Flood","Flood","No_flood","No_flood","No_flood","No_flood","No_flood","No_flood","No_flood","No_flood","No_flood","No_flood","No_flood","No_flood")),
  Ban = factor(c("Ban","Ban","Ban","No_ban","No_ban","No_ban","No_ban","No_ban","No_ban","Ban","Ban","Ban","No_ban","No_ban","No_ban","No_ban","No_ban","No_ban","Ban","Ban","Ban","No_ban","No_ban","No_ban","Ban","Ban","Ban","No_ban","No_ban","No_ban"))
)
Model_outputs <- subset(Combos, !(Flood %in% "Flood"))    # Removes combinations with Flood (don't want those)
Model_outputs <- mutate(Model_outputs, Number = seq(1:24))    # Need this to join them (can likely do it another way but this is easy)
# Then I need to predict yield values from my model outputs
  # Have got this for predicted yield, predicted yield + SE, predicted yield - SE
  # Use predict() to generate predictions for the new data
## Model outputs: from coefficients
Pred_coef <- predict(maximal9, newdata = Model_outputs)  
## Model outputs: SE
Pred_coef_se <- predict(maximal9, newdata = Model_outputs, se.fit = TRUE)    # This is re-calculating the main predictions and also the SE of those predictions
Pred_coef_se <- Pred_coef_se$se    # This takes just the SE
# Making them into a tibble, adding a 'Number' column to join later
Predictions_tibble <- tibble(Predicted_yield = Pred_coef,
                             Predicted_yield_se = Pred_coef_se)    # Above, saved as a tibble
Predictions_tibble <- mutate(Predictions_tibble, Number = seq(1:24))    # Need this to join them in next chunk (can likely do it another way but this is easy)
# Then I join the predictions outputs with information on the levels used to generate those predictions
## Joining the predictions to the model outputs names:
Model_outputs_joined <- left_join(Model_outputs, Predictions_tibble, by = "Number")
## Tidying Model_outputs_joined
Model_outputs_tidy <- subset(Model_outputs_joined, select = c(1:3, 5, 7, 8))    # Don't need (No_)flood or Numbers columns 
# Separating pre-ban and post-ban yields and renaming columns 
## I need these as two separate columns below
Model_outputs_ban <- Model_outputs_tidy %>%
  filter(Ban == "Ban") %>%
  rename(Predicted_yield_ban = Predicted_yield,
         Predicted_yield_ban_se = Predicted_yield_se)
Model_outputs_no_ban <- Model_outputs_tidy %>%
  filter(Ban == "No_ban") %>%
  rename(Predicted_yield_no_ban = Predicted_yield,
         Predicted_yield_no_ban_se = Predicted_yield_se)
# 4.3.1. Joining Yield and Production data -----------------------------------------
# Joining Yield model outputs with Production data
Production_model_joined <- left_join(Model_outputs_ban, Production_5y_bl, by = c("Maha_yala", "Irrigation_type", "New_zone"), multiple = "all")    # Joining with ban data
Production_model_joined <- left_join(Production_model_joined, Model_outputs_no_ban, by = c("Maha_yala", "Irrigation_type", "New_zone"))    # Then joining with no_ban data
# Tidying the joined data - selecting and reordering relevant columns
Production_model_joined <- subset(Production_model_joined, select = c(1,2,7,3,8,9,11,12,5,6))    # Removing columns I don't need & reordering
Production_model_joined2 <- Production_model_joined %>%
  mutate(Yield_reduc = Predicted_yield_ban - Predicted_yield_no_ban, 
         Yield_reduc_se = add_subt_se(Predicted_yield_ban_se, Predicted_yield_no_ban_se),
         Pc_change = Yield_reduc / Predicted_yield_no_ban,
         Pc_change_se = ratio_se(Yield_reduc, Predicted_yield_no_ban, Yield_reduc_se, Predicted_yield_no_ban_se))
# 4.4.1. Calculating land required -------------------------------------------------
## Need to calculate the difference in production with old land, and pre- and post- ban yields
## Ban land comes later (need to account for shortfall)
## Have incorporated error propagation methods for SE
Prod_shortfall <- Production_model_joined %>%
  mutate(Mean_net_land_no_ban = Mean_prod_5y / Predicted_yield_no_ban,    # P1 - no ban land: mean and SE
         Mean_net_land_no_ban_se = ratio_se(Mean_prod_5y, Predicted_yield_no_ban, Mean_prod_5y_sem, Predicted_yield_no_ban_se),
         
         Mean_net_prod_ban = Predicted_yield_ban * Mean_net_land_no_ban,
         Mean_net_prod_ban_se = product_se(Predicted_yield_ban, Mean_net_land_no_ban, Predicted_yield_ban_se, Mean_net_land_no_ban_se),
         
         Prod_dif = Mean_prod_5y - Mean_net_prod_ban,
         Prod_dif_se = add_subt_se(Mean_prod_5y_sem, Mean_net_prod_ban_se))
## Summarising the data
Prod_shortfall2 <- Prod_shortfall %>%
  summarise(Sum_prod_shortfall = sum(Prod_dif),
            Sum_prod_shortfall_se = sqrt(sum(Prod_dif_se^2, na.rm = T)),
            Sum_prod_pre = sum(Mean_prod_5y),
            Sum_prod_pre_se = sqrt(sum(Mean_prod_5y_sem^2, na.rm = T)),
            Sum_prod_post = sum(Mean_net_prod_ban),
            Sum_prod_post_se = sqrt(sum(Mean_net_prod_ban_se^2, na.rm = T))) %>%
  mutate(Pc_change = -Sum_prod_shortfall / Sum_prod_pre,    # 27.2% fall in production. 
         Pc_change_se = ratio_se(Sum_prod_shortfall, Sum_prod_pre, -Sum_prod_shortfall_se, Sum_prod_pre_se))
## Working out the percentage of production that takes place in each region, land without ban, production without land expansion and new production
Production_region_new <- Prod_shortfall %>%
  mutate(Pc_prod = Mean_prod_5y / Prod_shortfall2$Sum_prod_pre,    # Percentage of production by region/harvest/irrigation type. Not interested in SE here. 
         
         Additional_prod = Pc_prod * Prod_shortfall2$Sum_prod_shortfall,    # Additional production by region/harvest/irrigation type
         Additional_prod_se = Pc_prod * Prod_shortfall2$Sum_prod_shortfall_se,    # Multiplying by a constant so doing same to SE
         
         New_prod = Additional_prod + Mean_net_prod_ban,    # New production by region
         New_prod_se = add_subt_se(Additional_prod_se, Mean_net_prod_ban_se))
## Calculating new land
Land_region_new <- Production_region_new %>%
  mutate(New_land = New_prod / Predicted_yield_ban,
         New_land_se = ratio_se(New_prod, Predicted_yield_ban, New_prod_se, Predicted_yield_ban_se)) 
## Selecting columns and tidying data
Land_region_new_2 <- Land_region_new %>%
  mutate(Land_difference = New_land - Mean_net_land_no_ban,
         Land_difference_se = add_subt_se(New_land_se, Mean_net_land_no_ban_se),
         Pc_change_land = Land_difference / Mean_net_land_no_ban, 
         Pc_change_land_se = ratio_se(Land_difference, Mean_net_land_no_ban, Land_difference_se, Mean_net_land_no_ban_se))
# 4.5.1. Converting land to area sown by region-------------------------------------
# Now, need to convert these net land values to gross and then to area sown:
Production_model_joined_sown <- left_join(Land_region_new_2, New_correction_factor_unique, by = "Region") %>%     # Joining data with CFs
  rename(Correction_factor_GN = Mean_cf)
Production_model_joined_sown <- left_join(Production_model_joined_sown, Correction_factor_SH, by = c("Region", "Maha_yala")) %>%
  mutate(New_land_sown = (New_land / Correction_factor_GN) / Correction_factor_SH,
         New_land_sown_se = (New_land_se / Correction_factor_GN) / Correction_factor_SH,
         Old_land_sown = (Mean_net_land_no_ban / Correction_factor_GN) / Correction_factor_SH,
         Old_land_sown_se = (Mean_net_land_no_ban_se / Correction_factor_GN) / Correction_factor_SH)
# Increase by region:
Production_model_joined_sown_region <- Production_model_joined_sown %>%
  group_by(Maha_yala, Region) %>%
  summarize(Sum_sown_land_no_ban = sum(Old_land_sown, na.rm = T),
            Sum_sown_land_no_ban_se = sqrt(sum(Old_land_sown_se^2, na.rm = T)),
            Sum_sown_land_ban = sum(New_land_sown, na.rm = T),
            Sum_sown_land_ban_se = sqrt(sum(New_land_sown_se^2, na.rm = T)))
# Average yield loss
Av_yield_loss <- Production_model_joined_sown %>%
  subset(select = c(1:4, 7:10, 11:12)) %>%
  mutate(new_col = "A") %>%
  group_by(new_col) %>%
  summarise(Total_paddy_land = sum(Mean_net_land_no_ban),   # 946745
            Total_paddy_land_se = sqrt(sum(Mean_net_land_no_ban_se^2, na.rm = T)))
Av_yield_loss2 <- Production_model_joined_sown %>%
  subset(select = c(1:4, 7:10, 11:12)) %>%
  mutate(new_col = "A") %>%
  filter(Mean_net_land_no_ban != 0) %>%
  mutate(Pre_ban_prop_land_area = Mean_net_land_no_ban / Av_yield_loss$Total_paddy_land,
         Pre_ban_prop_land_area_se = ratio_se(Mean_net_land_no_ban, Av_yield_loss$Total_paddy_land, Mean_net_land_no_ban_se, Av_yield_loss$Total_paddy_land_se),
         
         Weighted_pre_ban_yield = Predicted_yield_no_ban * Pre_ban_prop_land_area,
         Weighted_pre_ban_yield_se = product_se(Predicted_yield_no_ban, Pre_ban_prop_land_area, Predicted_yield_no_ban_se, Pre_ban_prop_land_area_se),
         
         Weighted_post_ban_yield = Predicted_yield_ban * Pre_ban_prop_land_area,
         Weighted_post_ban_yield_se = product_se(Predicted_yield_ban, Pre_ban_prop_land_area, Predicted_yield_ban_se, Pre_ban_prop_land_area_se)) %>%
  group_by(new_col) %>%
  summarise(Av_post_ban_yield = sum(Weighted_post_ban_yield), 
            Av_post_ban_yield_se = sqrt(sum(Weighted_post_ban_yield_se^2, na.rm = T)),
            Av_pre_ban_yield = sum(Weighted_pre_ban_yield),
            Av_pre_ban_yield_se = sqrt(sum(Weighted_pre_ban_yield_se^2, na.rm = T))) %>%
  mutate(Difference = Av_post_ban_yield - Av_pre_ban_yield,
         PC_difference = Difference / Av_pre_ban_yield,
         Difference_se = add_subt_se(Av_post_ban_yield_se, Av_pre_ban_yield_se),
         PC_difference_se = ratio_se(Difference, Av_pre_ban_yield, Difference_se, Av_pre_ban_yield_se))
# Summing Maha and Yala values and taking cropping intensity into account (dividing the resulting sum by 1.4)
## Cropping intensity = 140% = 1.4 (https://corigap.irri.org/countries/sri-lanka)
### Except for Jaffna, which is only Maha cultivation - have left as it is. 
## Cropping intensity = gross land total / net land total (https://prepp.in/news/e-492-cropping-intensity-agriculture-notes)
### Where gross land total = sum of Maha and Yala, regardless of land re-use
### And net land total = sum of Maha and Yala, accounting for land re-use
#### Note - not using this terminology to avoid confusion with other net and gross definition!
## Net land = gross land / 1.4
Production_model_joined_sown_region2 <- Production_model_joined_sown_region %>%
  group_by(Region) %>%
  filter(!is.na(Sum_sown_land_no_ban)) %>%    # Removing Jaffna Yala value (it's NA because there's no harvest)
  summarize(
    Sum_sown_land_no_ban = sum(ifelse(Region == "Jaffna", Sum_sown_land_no_ban, Sum_sown_land_no_ban / 1.4)),
    Sum_sown_land_no_ban_se = sqrt(sum(ifelse(Region == "Jaffna", Sum_sown_land_no_ban_se^2, (Sum_sown_land_no_ban_se / 1.4)^2))),
    
    Sum_sown_land_ban = sum(ifelse(Region == "Jaffna", Sum_sown_land_ban, Sum_sown_land_ban / 1.4)),
    Sum_sown_land_ban_se = sqrt(sum(ifelse(Region == "Jaffna", Sum_sown_land_ban_se^2, (Sum_sown_land_ban_se / 1.4)^2))),
    
    Sum_sown_land_increase = Sum_sown_land_ban - Sum_sown_land_no_ban,
    Sum_sown_land_increase_se = add_subt_se(Sum_sown_land_ban_se, Sum_sown_land_no_ban_se))
# Joining total land in region 
data_zone_ha <- data_zone_km %>%
  mutate(Region_area_ha = Area_km2 * 100) %>%
  subset(select = c(1,7))
data_zone_ha_2 <- data_zone_ha %>%
  summarise(sum(Region_area_ha))
data_zone_ha_3 <- data_zone_ha %>%
  mutate(Pc_SL = (Region_area_ha / data_zone_ha_2$`sum(Region_area_ha)`) *100)
# Sanity check - additional land as pc of region land?
Production_model_joined_sown_region3 <- left_join(Production_model_joined_sown_region2, data_zone_ha, by = "Region") %>%
  mutate(Increase_pc_region = (Sum_sown_land_increase / Region_area_ha) * 100,
         Increase_pc_region_se = (Sum_sown_land_increase_se / Region_area_ha) * 100)
# Exploring production model joined sown region 3
Production_model_joined_sown_region3_2 <- Production_model_joined_sown_region3 %>%
  mutate(PC_paddy_pre_ban = Sum_sown_land_no_ban / Region_area_ha,
         PC_paddy_pre_ban_se = Sum_sown_land_no_ban_se / Region_area_ha)
# Land increase across SL
Production_model_SL <- Production_model_joined_sown_region3 %>%
  summarise(Total_land_pre = sum(Sum_sown_land_no_ban),
            Total_land_pre_se = sqrt(sum(Sum_sown_land_no_ban_se^2, na.rm = T)),
            Total_land_post = sum(Sum_sown_land_ban),
            Total_land_post_se = sqrt(sum(Sum_sown_land_no_ban_se^2, na.rm = T)),
            Land_increase = Total_land_post - Total_land_pre,
            Land_increase_se = add_subt_se(Total_land_post_se, Total_land_pre_se),
            Total_land_SL = sum(Region_area_ha)) %>%
  mutate(Pc_increase = Land_increase / Total_land_pre,
         Pc_increase_se = ratio_se(Land_increase, Total_land_pre, Land_increase_se, Total_land_pre_se),
         Land_increase_pc_SL = Land_increase / Total_land_SL,
         Land_increase_pc_SL_se1 = Land_increase_se / Total_land_SL)
# Land increase by irrigation type
## Summing Maha and Yala values and taking cropping intensity into account (dividing the resulting sum by 1.4)
Production_model_irrig_type <- Production_model_joined_sown %>%
  group_by(Maha_yala, Irrigation_type, Region) %>%
  summarise(
    Land_pre = sum(Mean_net_land_no_ban),
    Land_pre_se = sum(Mean_net_land_no_ban_se, na.rm = T),
    Land_post = sum(New_land),
    Land_post_se = sum(Mean_net_land_no_ban_se,na.rm = T),
    Region_Jaffna = ifelse(Region == "Jaffna", TRUE, FALSE)
  ) %>%
  mutate(
    Land_pre = ifelse(Region_Jaffna, Land_pre, Land_pre / 1.4),
    Land_pre_se = ifelse(Region_Jaffna, Land_pre_se, (Land_pre_se / 1.4)),
    Land_post = ifelse(Region_Jaffna, Land_post, Land_post / 1.4),
    Land_post_se = ifelse(Region_Jaffna, Land_post_se, (Land_post_se / 1.4))) %>%
  group_by(Irrigation_type) %>%
  summarise(
    Land_pre = sum(Land_pre),
    Land_pre_se = sqrt(sum(Land_pre_se)^2),
    Land_post = sum(Land_post),
    Land_post_se = sqrt(sum(Land_post_se)^2),
  ) %>%
  mutate(Difference = Land_post - Land_pre,
         Difference_se = add_subt_se(Land_post_se, Land_pre_se),
         Pc_increase = Difference / Land_pre,
         Pc_increase_se = ratio_se(Difference, Land_pre, Difference_se, Land_pre_se))
# 4.6.1. Comparing land increase to available land
  # Struggled to find good quality data, so have taken total ag land by district from 2002 survey (latest date). 
  # Assuming urban land is minimal in most districts - will flag any obvious issues. 
  # Alternatively, did it using forest cover from Mongabay, originally from Global Forest Watch: https://rainforests.mongabay.com/deforestation/archive/Sri_Lanka.htm
  # is there more forest by district than additional paddy land
  # Yes for all districts except for Jaffna (even when including SEs). Jaffna has weird land use because of the war, so it doesn't mean much. 
Land_outputs2 <- left_join(data_tree_cover_total, Production_model_joined_sown_region3, by = "Region")
Land_outputs2 <- Land_outputs2 %>%
  mutate(Tree_cover_2020 - (Sum_sown_land_increase + Sum_sown_land_increase_se))
Land_outputs3 <- Land_outputs2 %>%
  subset(select = c(1,2)) %>%
  mutate(new_col = "A") %>%
  group_by(new_col) %>%
  summarise(total_tree_cover2020 = sum(Tree_cover_2020))
# 4.7.1. Pre-ban production by Region ------------------------------------------
Production_5y_bl_region <- Production_5y_bl %>%
  group_by(Region) %>%
  summarize(Sum_prod = sum(Mean_prod_5y),
            Sum_prod_se = sqrt(sum(Mean_prod_5y_sem^2)))
Production_5y_bl_region_ecoregion <- left_join(Production_5y_bl_region, data_ecoregion_alloc, by = "Region")
ggplot(Production_5y_bl_region_ecoregion, aes(x = Region, y = Sum_prod, fill = Ecoregion)) +
  geom_bar(stat = "identity") +
  geom_errorbar(aes(ymin = Sum_prod - Sum_prod_se, ymax = Sum_prod + Sum_prod_se), 
                width = 0.2, colour = "black") +
  labs(title = "Production by Region", x = "Region", y = "Production") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
# 4.8.1. Looking into Polonnaruwa and Nuwara Eliya for write up ----------------
WU_prod_explore <- Production_model_joined_sown %>%
  group_by(Region, New_zone, Irrigation_type) %>%
  summarise(across(starts_with("Mean_prod"):ends_with("Old_land_sown_se"), sum, na.rm = TRUE)) %>%
  mutate(across(starts_with("Mean_prod"):ends_with("Old_land_sown_se"), ~ . / 1.4))
WU_prod_explore1 <- Production_model_joined_sown %>%
  group_by(Region, New_zone, Irrigation_type) %>%
  summarise(Mean_net_land_no_ban = sum(Mean_net_land_no_ban, na.rm = TRUE), .groups = "drop", 
            Mean_net_land_no_ban_se = sqrt(sum(Mean_net_land_no_ban_se^2, na.rm = T))) %>%
  mutate(Mean_net_land_no_ban = Mean_net_land_no_ban / 1.4,
         Mean_net_land_no_ban_se = Mean_net_land_no_ban_se / 1.4)
WU_prod_explore1 <- WU_prod_explore1 %>%
  group_by(Region) %>%
  mutate(Prop = Mean_net_land_no_ban / sum(Mean_net_land_no_ban),
         Prop_se = ratio_se(Mean_net_land_no_ban, sum(Mean_net_land_no_ban), Mean_net_land_no_ban_se, sqrt(sum(Mean_net_land_no_ban_se^2))))
WU_prod_explore2 <- Production_model_joined_sown %>%
  group_by(Region, New_zone, Maha_yala) %>%
  summarise(Mean_net_land_no_ban = sum(Mean_net_land_no_ban, na.rm = TRUE), .groups = "drop") %>%
  mutate(Mean_net_land_no_ban = Mean_net_land_no_ban / 1.4)
WU_prod_explore2 <- WU_prod_explore2 %>%
  group_by(Region) %>%
  mutate(Prop = Mean_net_land_no_ban / sum(Mean_net_land_no_ban))
ggplot(WU_prod_explore, aes(x = Region, y = Mean_net_land_no_ban, fill = Irrigation_type)) +
  geom_bar(stat = "identity", position = "stack") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  labs(y = "Sum of Mean_net_land_no_ban", 
       x = "Region",
       fill = "Irrigation Type",
       title = "Stacked Bar Plot by Irrigation Type")
# 4.9.1. Average yield by district pre- and post-ban --------------------------
# Need to calculate weighted averages
# This calculates sum of paddy land by region and cultivation season
Av_yield_by_district <- Production_model_joined_sown %>%
  subset(select = c(1:4, 7:12,22,23)) %>%
  group_by(Region, Maha_yala) %>%
  summarise(Total_paddy_pre = sum(Mean_net_land_no_ban),
            Total_paddy_pre_se = sqrt(sum(Mean_net_land_no_ban_se^2)),
            Total_paddy_post = sum(New_land),
            Total_paddy_post_se = sqrt(sum(New_land_se^2)))
# Selecting columns
Av_yield_by_district2 <- Production_model_joined_sown %>%
  subset(select = c(1:4, 7:12,22,23))
# Working out weighted averages (first doing weights, then summing)
Av_yield_by_district3 <- left_join(Av_yield_by_district, Av_yield_by_district2, by = c("Region", "Maha_yala")) %>%
  subset(select = c(1,2,8,7,3:6,9:16)) %>%
  mutate(Pre_ban_land_weight = Mean_net_land_no_ban / Total_paddy_pre,
         Pre_ban_land_weight_se = ratio_se(Mean_net_land_no_ban, Total_paddy_pre, Mean_net_land_no_ban_se, Total_paddy_pre_se),
         Pre_ban_yield_weighted = Predicted_yield_no_ban * Pre_ban_land_weight,
         Pre_ban_yield_weighted_se = product_se(Predicted_yield_no_ban, Pre_ban_land_weight, Predicted_yield_no_ban_se, Pre_ban_land_weight_se),
         Post_ban_land_weight = New_land / Total_paddy_post,
         Post_ban_land_weight_se = ratio_se(New_land, Total_paddy_post, New_land_se, Total_paddy_post_se),
         Post_ban_yield_weighted = Predicted_yield_ban * Post_ban_land_weight,
         Post_ban_yield_weighted_se = product_se(Predicted_yield_ban, Post_ban_land_weight, Predicted_yield_ban_se, Post_ban_land_weight_se)) %>%
  group_by(Region,Maha_yala) %>%
  summarise(Paddy_yield_pre = sum(Pre_ban_yield_weighted),
            Paddy_yield_pre_se = sqrt(sum(Pre_ban_yield_weighted_se^2)),
            Paddy_yield_post = sum(Post_ban_yield_weighted),
            Paddy_yield_post_se = sum(sqrt(Post_ban_yield_weighted_se^2)))
# Working out sum of paddy land by region only
Av_yield_by_district4 <- Av_yield_by_district %>%
  group_by(Region) %>%
  summarise(Total_paddy_pre = sum(Total_paddy_pre),
            Total_paddy_pre_se = sqrt(sum(Total_paddy_pre_se^2)),
            Total_paddy_post = sum(Total_paddy_post),
            Total_paddy_post_se = sqrt(sum(Total_paddy_post_se^2)))
# Working out weights
Av_yield_by_district5 <- left_join(Av_yield_by_district3, Av_yield_by_district4, by = c("Region"))
Av_yield_by_district6 <- left_join(Av_yield_by_district5, Av_yield_by_district, by = c("Region", "Maha_yala")) %>%
  rename(Region_paddy_pre = Total_paddy_pre.x,
         Region_paddy_pre_se = Total_paddy_pre_se.x,
         Region_paddy_post = Total_paddy_post.x,
         Region_paddy_post_se = Total_paddy_post_se.x,
         CS_paddy_pre = Total_paddy_pre.y,
         CS_paddy_pre_se = Total_paddy_pre_se.y,
         CS_paddy_post = Total_paddy_post.y,
         CS_paddy_post_se = Total_paddy_post_se.y)
Av_yield_by_district_7 <- Av_yield_by_district6 %>%
  mutate(Pre_ban_land_weight = CS_paddy_pre / Region_paddy_pre,
         Pre_ban_land_weight_se = ratio_se(CS_paddy_pre, Region_paddy_pre, CS_paddy_pre_se, Region_paddy_pre_se),
         Pre_ban_yield_weighted = Paddy_yield_pre * Pre_ban_land_weight,
         Pre_ban_yield_weighted_se = product_se(Paddy_yield_pre, Pre_ban_land_weight, Paddy_yield_pre_se, Pre_ban_land_weight_se),
         
         Post_ban_land_weight = CS_paddy_post / Region_paddy_post,
         Post_ban_land_weight_se = ratio_se(CS_paddy_post, Region_paddy_post, CS_paddy_post_se, Region_paddy_post_se),
         Post_ban_yield_weighted = Paddy_yield_post * Post_ban_land_weight,
         Post_ban_yield_weighted_se = product_se(Paddy_yield_post, Post_ban_land_weight, Paddy_yield_post_se, Post_ban_land_weight_se)) %>%
  group_by(Region) %>%
  summarise(Paddy_yield_pre = sum(Pre_ban_yield_weighted, na.rm = T),
            Paddy_yield_pre_se = sqrt(sum(Pre_ban_yield_weighted_se^2)),
            Paddy_yield_post = sum(Post_ban_yield_weighted,  na.rm = T),
            Paddy_yield_post_se = sum(sqrt(Post_ban_yield_weighted_se^2))) %>%
  mutate(Yield_fall = Paddy_yield_pre - Paddy_yield_post,
         Yield_fall_se = add_subt_se(Paddy_yield_pre_se, Paddy_yield_post_se))




# 4.10.1. Making maps
  # I used these two resources:
  # https://r-graph-gallery.com/325-background-map-from-geojson-format-in-r.html 
  # https://r-graph-gallery.com/327-chloropleth-map-from-geojson-with-ggplot2.html?utm_content=cmp-true
# Process:
  # Get district-level data for the map
  # Convert that data into another format (and add Region data)
  # Join the data to plot on the map with the geographical data
  # Plot the map using ggplot2
# 4.10.2: Geographical data ---------------------------------------------------------
# From the web, in GeoJSON format, and then converting it to another format
SL_districts_fortified <- tidy(SL_districts)    # Changing format, so that I can use it in ggplot2
# Ploting this alone to check it looks right
ggplot() +
  geom_polygon(data = SL_districts_fortified, aes( x = long, y = lat, group = group), fill="#69b3a2", color="white") +
  theme_void() +
  coord_map()
# 4.10.3. Data to plot --------------------------------------------------------------
  # In this case, asking what percentage of the land in the region would have to be converted to rice for production to stay the same
  # First, need to tweak my geographical data: region (district) is a number in 'id' column; the corresponding region is in Data_region_link
  # Joining region link data with the production data and changing format. 
Production_increase_pc_map <- left_join(Production_model_joined_sown_region3, Data_region_link, by = "Region")
Production_increase_pc_map <- Production_increase_pc_map %>% 
  mutate(Increase_pc_region = Increase_pc_region / 100)
Production_increase_pc_map$id <- as.character(Production_increase_pc_map$id)    # My id column is in the wrong format
  # Joining the new production data with the map data
SL_districts_joined_pc = left_join(SL_districts_fortified, Production_increase_pc_map, by = "id")
# 4.10.4. Percentage of land in region that must be converted to rice ---------------
p1 <-
  ggplot() +
  geom_polygon(data = SL_districts_joined_pc, aes(fill = Increase_pc_region, x = long, y = lat, group = group)) +
  theme_minimal() +
  theme(axis.title = element_blank()) +
  coord_map() +
  scale_fill_viridis_c(name = "Percentage increase", guide = guide_legend( keyheight = unit(4, units = "mm"), keywidth=unit(10, units = "mm"), label.position = "bottom", title.position = 'top', nrow=1)) +
  theme(
    text = element_text(color = "#22211d", size = 11),
    legend.position = c(0.8, 0.92),
    axis.text = element_blank(),
    panel.grid.major = element_blank()
  )
p1 <- ggplot() +
  geom_polygon(data = SL_districts_joined_pc, aes(fill = Increase_pc_region, x = long, y = lat, group = group)) +
  coord_map() +
  theme_minimal() +
  theme(axis.title = element_blank(),
        plot.title = element_text(size = 22, hjust = 0.5, face = "bold"),
        legend.text = element_text(size = 15),
        legend.title = element_text(size = 17),
        legend.key.width = unit(0.17, "npc")) +
  labs(title = "Land Conversion as a Percentage \nof District") + 
  scale_fill_viridis_c(name = "Land conversion (%)",
                       guide = guide_colorbar(title.position = "top", 
                                              title.hjust = 0.5,
                                              label.position = "bottom",
                                              label.hjust = 0.5,
                                              direction = "horizontal",
                                              barheight = unit(4, "mm"),
                                              ticks = F,
                                              nbin = 100),
                       limits = c(0,0.12),
                       label = scales::percent_format(),
                       direction = -1) +
  theme(text = element_text(color = "#22211d", size = 20),
        legend.position = "bottom",
        axis.text = element_blank(),
        panel.grid.major = element_blank())
p2 <- ggplot() +
  geom_polygon(data = SL_districts_joined_pc, aes(fill = Sum_sown_land_increase, x = long, y = lat, group = group)) +
  theme_minimal() +
  theme(axis.title = element_blank()) +
  coord_map() +
  scale_fill_viridis_c(name = "Percentage increase", guide = guide_legend( keyheight = unit(4, units = "mm"), keywidth=unit(10, units = "mm"), label.position = "bottom", title.position = 'top', nrow=1)) +
  theme(
    text = element_text(color = "#22211d", size = 11),
    legend.position = c(0.8, 0.92),
    axis.text = element_blank(),
    panel.grid.major = element_blank()
  )
p2 <- ggplot() +
  geom_polygon(data = SL_districts_joined_pc, aes(fill = Sum_sown_land_increase, x = long, y = lat, group = group)) +
  coord_map() +
  theme_minimal() +
  labs(title = "Land Conversion as an Absolute Value \nby District") +
  theme(axis.title = element_blank(),
        plot.title = element_text(size = 22, hjust = 0.5, face = "bold"),
        legend.text = element_text(size = 15),
        legend.title = element_text(size = 17),
        legend.key.width = unit(0.17, "npc")) +
  scale_fill_viridis_c(name = "Land conversion (ha)",
                       guide = guide_colorbar(title.position = "top", 
                                              title.hjust = 0.5,
                                              label.position = "bottom",
                                              label.hjust = 0.5,
                                              direction = "horizontal",
                                              barheight = unit(4, "mm"),
                                              ticks = F,
                                              nbin = 100),
                       limits = c(0,50000),
                       direction = -1) +
  theme(text = element_text(color = "#22211d", size = 20),
        legend.position = "bottom",
        axis.text = element_blank(),
        panel.grid.major = element_blank())
# 4.10.5. Simple rice production map -------------------------------------------
  # I've used another way of reading in the data, from sf package - lets me add labels later more easily with geom_sf_text()
## Tidying map data:
map$shapeName <- str_remove(map$shapeName, " District")
map <- map %>% 
  mutate(shapeName = ifelse(shapeName == "Kilinochchi", "Killinochchi", shapeName),
         shapeName = ifelse(shapeName == "Mullaitivu", "Mulativu", shapeName),
         shapeName = ifelse(shapeName == "Nuwara Eliya", "Nuwaraeliya", shapeName))
## Tidying data:
Total_production <- Production_5y_bl_region %>%
  mutate(shapeName = Region)
## Joining the map data with production data
map <-   left_join(map, Total_production, by = c("shapeName"))
## Plotting the map
p2 <-
  ggplot(map) +
  geom_sf(color = NA, aes(fill = Sum_prod)) +
  geom_sf_text(aes(label = shapeName), size = 3.5) +
  scale_fill_viridis_c(direction = -1, name = "Rice production in region", guide = guide_legend( keyheight = unit(4, units = "mm"), keywidth=unit(10, units = "mm"), label.position = "bottom", title.position = 'top', nrow=1)) +
  labs(title = "Rice production by region, kg") +
  theme_fivethirtyeight() +
  theme(
    text = element_text(color = "#22211d", size = 11),
    legend.position = c(0.78, 0.92),
    axis.text = element_blank(),
    panel.grid.major = element_blank()
  )

# 5

# SECTION 5 - BIODIVERSITY
# 5.1.1. Chaudry & Brooks (2018) data ------------------------------------------
  # Tidy the data:
  # Rename first two columns
data_chaudhary_brooks2 <- rename(data_chaudhary_brooks, Ecoregion = `…...1`, CF_type = `…...2` )
  # Remove '...No' added by R when importing dataset
colnames(data_chaudhary_brooks2) <- str_replace(colnames(data_chaudhary_brooks2), "\\.\\.\\.\\d+$", "")
  # Paste row 1 into headers
colnames(data_chaudhary_brooks2)[3:272] <- paste(colnames(data_chaudhary_brooks2)[3:272], data_chaudhary_brooks2[1, 3:272], sep = "_")
  # Replace spaces in headers with _
colnames(data_chaudhary_brooks2)[3:272] <- gsub(" ", "_", colnames(data_chaudhary_brooks2)[3:272])
  # Remove row 1
data_chaudhary_brooks2 <- data_chaudhary_brooks2[-1, ]
  # Renaming Ecoregions (need this later)
data_chaudhary_brooks2$Ecoregion[data_chaudhary_brooks2$Ecoregion == "Deccan thorn scrub forests"] <- "Deccan Thorn Scrub Forests"
data_chaudhary_brooks2$Ecoregion[data_chaudhary_brooks2$Ecoregion == "Sri Lanka dry-zone dry evergreen forests"] <- "Sri Lanka Dry-Zone Dry Evergreen Forests"
data_chaudhary_brooks2$Ecoregion[data_chaudhary_brooks2$Ecoregion == "Sri Lanka lowland rain forests"] <- "Sri Lanka Lowland Rain Forests"
data_chaudhary_brooks2$Ecoregion[data_chaudhary_brooks2$Ecoregion == "Sri Lanka montane rain forests"] <- "Sri Lanka Montane Rain Forests"
  # Next, I need to select only the CFs I need - for now I will keep: Cropland, using intense (conventional) and minimal (organic)  
selected_columns <- c("Ecoregion", "CF_type", grep("CF_Lt_crop|CF_Int_crop", colnames(data_chaudhary_brooks2), value = TRUE))
data_chaudhary_brooks3 <- data_chaudhary_brooks2 %>% 
  dplyr::select(all_of(selected_columns))
  # Renaming columns here (they were too long). Unit = Potential_species_loss*years/m2
data_chaudhary_brooks3 <- data_chaudhary_brooks3 %>%
  dplyr::select(1:32) %>%
  rename_with(~ gsub("(^Mean_values_|_\\[Unit_-_Potential_species_loss\\*years/m2\\]|_crop$)", "", .x), -c(1, 2))
# 5.1.2. Allocating Regions into Ecoregions ----------------------------------------
  # Check CRS of districts and ecoregions are the same (they are)
st_crs(districts)
st_crs(ecoregions)
  # Fixing errors in the data (seems to be some overlap)
districts <- st_make_valid(districts)
ecoregions <- st_make_valid(ecoregions)
  # Spatial join the two maps
districts_eco <- st_join(districts, ecoregions)
  # Intersect the two maps - this takes a long time, just let it run!
intersect <- st_intersection(districts, ecoregions)
  # Calculate the area of each resulting polygon
intersect$area <- st_area(intersect)
  # Group the resulting data by district and ecoregion, and summarize the area
district_eco_area <- intersect %>% 
  group_by(shapeName, ECO_NAME) %>% 
  summarize(area = sum(area))
  # Calculate the proportion of each district that is found in each ecoregion
district_eco_prop <- district_eco_area %>% 
  group_by(shapeName) %>% 
  mutate(prop_area = area / sum(area))
  # Tidying data:
district_eco_prop <- district_eco_prop %>%
  rename("Region" = "shapeName",
         "Ecoregion" = "ECO_NAME",
         "Area" = "area",
         "Geometry" = "geometry",
         "Prop_area" = "prop_area")
district_eco_prop$Region <- str_replace_all(district_eco_prop$Region, 
                                            c("Kilinochchi" = "Killinochchi", "Mullaitivu" = "Mulativu", "Nuwara Eliya" = "Nuwaraeliya", " District" = ""))
  # Now have data for how much of each region falls into each ecoregion. 
  # Next, need to allocate my paddy land using this data. 
  # Land data is in Production_model_joined_sown_region3. 
## Working out how much land is needed by Ecoregion within Regions:
summary_eco_prop <- left_join(Production_model_joined_sown_region3, district_eco_prop, by = "Region") %>%
  mutate(Land_no_ban = Prop_area * Sum_sown_land_no_ban,
         Land_no_ban_se = Prop_area * Sum_sown_land_no_ban_se,
         Land_ban = Prop_area * Sum_sown_land_ban,
         Land_ban_se = Prop_area * Sum_sown_land_ban_se)
## Summarising down by Ecoregion
summary_eco_prop2 <- summary_eco_prop %>%
  group_by(Ecoregion) %>%
  summarise(Land_no_ban = sum(Land_no_ban),
            Land_no_ban_se = sqrt(sum(Land_no_ban_se^2)),
            Land_ban = sum(Land_ban),
            Land_ban_se = sqrt(sum(Land_ban_se^2))) %>%
  mutate(Land_increase = Land_ban - Land_no_ban,
         Land_increase_se = add_subt_se(Land_ban_se, Land_no_ban_se),
         Pc_change = Land_increase / Land_no_ban,
         Pc_change_se = ratio_se(Land_increase, Land_no_ban, Land_increase_se, Land_no_ban_se))
# 5.1.3. Working out biodiversity impact -------------------------------------------
## Joining with C&B data
data_chaudhary_brooks4 <- data_chaudhary_brooks3 %>%
  filter(Ecoregion != "Sri Lanka") 
data_chaudhary_brooks5 <- 
  left_join(data_chaudhary_brooks4, summary_eco_prop2, by = "Ecoregion")
# Have to remove units (not sure if I can ac do this?)
data_chaudhary_brooks5 <- drop_units(data_chaudhary_brooks5) %>%
  mutate_at(vars(3:23), ~as.numeric(.))
# Working out values. CFs are all in one column (trans and occ)
## BAU Existing land: Intense CF * Land area (existing)
## Org Existing land: Lt CF * Land area (existing)
## Org Additional land: Lt CF * Land area (increase)
## And calculate SEs for each. 
Biodiversity_impact <- data_chaudhary_brooks5 %>%
  mutate(BAU_Existing_Mammals_Int = Mammals_CF_Int * Land_no_ban * 10000,
         BAU_Existing_Birds_Int = Birds_CF_Int * Land_no_ban * 10000,
         BAU_Existing_Amphibians_Int = Amphibians_CF_Int * Land_no_ban * 10000,
         BAU_Existing_Reptiles_Int = Reptiles_CF_Int * Land_no_ban * 10000,
         BAU_Existing_Plants_Int = Plants_CF_Int * Land_no_ban * 10000,
         
         Org_Existing_Mammals_Lt = Mammals_CF_Lt * Land_no_ban * 10000,
         Org_Existing_Birds_Lt = Birds_CF_Lt * Land_no_ban * 10000,
         Org_Existing_Amphibians_Lt = Amphibians_CF_Lt * Land_no_ban * 10000,
         Org_Existing_Reptiles_Lt = Reptiles_CF_Lt * Land_no_ban * 10000,
         Org_Existing_Plants_Lt = Plants_CF_Lt * Land_no_ban * 10000,
         
         Org_Additional_Mammals_Lt = Mammals_CF_Lt * Land_increase * 10000,
         Org_Additional_Birds_Lt = Birds_CF_Lt * Land_increase * 10000,
         Org_Additional_Amphibians_Lt = Amphibians_CF_Lt * Land_increase * 10000,
         Org_Additional_Reptiles_Lt = Reptiles_CF_Lt * Land_increase * 10000,
         Org_Additional_Plants_Lt = Plants_CF_Lt * Land_increase * 10000,
         
         BAU_Existing_Mammals_Int_SE = product_se(Mammals_CF_Int, Land_no_ban*10000, 0, Land_no_ban_se*10000),
         BAU_Existing_Birds_Int_SE = product_se(Birds_CF_Int, Land_no_ban*10000, 0, Land_no_ban_se*10000),
         BAU_Existing_Amphibians_Int_SE = product_se(Amphibians_CF_Int, Land_no_ban*10000, 0, Land_no_ban_se*10000),
         BAU_Existing_Reptiles_Int_SE = product_se(Reptiles_CF_Int, Land_no_ban*10000, 0, Land_no_ban_se*10000),
         BAU_Existing_Plants_Int_SE = product_se(Plants_CF_Int, Land_no_ban*10000, 0, Land_no_ban_se*10000),
         
         Org_Existing_Mammals_Lt_SE = product_se(Mammals_CF_Lt, Land_no_ban*10000, 0, Land_no_ban_se*10000),
         Org_Existing_Birds_Lt_SE = product_se(Birds_CF_Lt, Land_no_ban*10000, 0, Land_no_ban_se*10000),
         Org_Existing_Amphibians_Lt_SE = product_se(Amphibians_CF_Lt, Land_no_ban*10000, 0, Land_no_ban_se*10000),
         Org_Existing_Reptiles_Lt_SE = product_se(Reptiles_CF_Lt, Land_no_ban*10000, 0, Land_no_ban_se*10000),
         Org_Existing_Plants_Lt_SE = product_se(Plants_CF_Lt, Land_no_ban*10000, 0, Land_no_ban_se*10000),
         
         Org_Additional_Mammals_Lt_SE = product_se(Mammals_CF_Lt, Land_increase*10000, 0, Land_increase_se*10000),
         Org_Additional_Birds_Lt_SE = product_se(Birds_CF_Lt, Land_increase*10000, 0, Land_increase_se*10000),
         Org_Additional_Amphibians_Lt_SE = product_se(Amphibians_CF_Lt, Land_increase*10000, 0, Land_increase_se*10000),
         Org_Additional_Reptiles_Lt_SE = product_se(Reptiles_CF_Lt, Land_increase*10000, 0, Land_increase_se*10000),
         Org_Additional_Plants_Lt_SE = product_se(Plants_CF_Lt, Land_increase*10000, 0, Land_increase_se*10000))
Biodiversity_impact <- Biodiversity_impact %>%
  mutate(across(41:50, ~ replace(., 1:4, 0)),
         across(56:65, ~ replace(., 1:4, 0)))   # This removes transformation values for land that was already occupied before the ban (for value and SE)
# Summing across the different taxa to obtain total values. NB Occupation values need multiplying (used 40)
# First, multiplying Occupation values by 40, leaving transformation the same. 
Biodiversity_impact2 <- Biodiversity_impact %>%
  mutate(across(c(41:70), ~ ifelse(row_number() %in% 5:8, . * 40, .)))
# Second, work out impacts for each taxon
## First, summing losses due to organic ag (additional trans, additional occ, existing occ).
## Then, taking those losses and subtracting what would've happened anyway due to intense BAU ag (existing occ)
Biodiversity_impact3 <- Biodiversity_impact2 %>%
  mutate(Mammals_org_loss = Org_Existing_Mammals_Lt + Org_Additional_Mammals_Lt,
         Mammals_loss = Mammals_org_loss - BAU_Existing_Mammals_Int,
         Mammals_org_loss_SE = add_subt_se(Org_Existing_Mammals_Lt_SE, Org_Additional_Mammals_Lt_SE),
         Mammals_loss_SE = add_subt_se(Mammals_org_loss_SE, BAU_Existing_Mammals_Int_SE),
         
         Birds_org_loss = Org_Existing_Birds_Lt + Org_Additional_Birds_Lt,
         Birds_loss = Birds_org_loss - BAU_Existing_Birds_Int,
         Birds_org_loss_SE = add_subt_se(Org_Existing_Birds_Lt_SE, Org_Additional_Birds_Lt_SE),
         Birds_loss_SE = add_subt_se(Birds_org_loss_SE, BAU_Existing_Birds_Int_SE), 
         
         Amphibians_org_loss = Org_Existing_Amphibians_Lt + Org_Additional_Amphibians_Lt,
         Amphibians_loss = Amphibians_org_loss - BAU_Existing_Amphibians_Int,
         Amphibians_org_loss_SE = add_subt_se(Org_Existing_Amphibians_Lt_SE, Org_Additional_Amphibians_Lt_SE),
         Amphibians_loss_SE = add_subt_se(Amphibians_org_loss_SE, BAU_Existing_Amphibians_Int_SE), 
         
         Reptiles_org_loss = Org_Existing_Reptiles_Lt + Org_Additional_Reptiles_Lt,
         Reptiles_loss = Reptiles_org_loss - BAU_Existing_Reptiles_Int,
         Reptiles_org_loss_SE = add_subt_se(Org_Existing_Reptiles_Lt_SE, Org_Additional_Reptiles_Lt_SE),
         Reptiles_loss_SE = add_subt_se(Reptiles_org_loss_SE, BAU_Existing_Reptiles_Int_SE), 
         
         Plants_org_loss = Org_Existing_Plants_Lt + Org_Additional_Plants_Lt,
         Plants_loss = Plants_org_loss - BAU_Existing_Plants_Int,
         Plants_org_loss_SE = add_subt_se(Org_Existing_Plants_Lt_SE, Org_Additional_Plants_Lt_SE),
         Plants_loss_SE = add_subt_se(Plants_org_loss_SE, BAU_Existing_Plants_Int_SE))
# 5.1.4. Rearranging data to get different outputs------------------------------
# Selecting only columns I need
Biodiversity_impact4 <- Biodiversity_impact3 %>%
  dplyr::select("Ecoregion", "CF_type",
                "Mammals_loss", "Mammals_loss_SE",
                "Birds_loss", "Birds_loss_SE", 
                "Amphibians_loss", "Amphibians_loss_SE",
                "Reptiles_loss", "Reptiles_loss_SE",
                "Plants_loss", "Plants_loss_SE")
# Working out vertebrate total too. 
Biodiversity_impact5 <- Biodiversity_impact4 %>%
  mutate(Verts_loss = Mammals_loss + Birds_loss + Amphibians_loss + Reptiles_loss,
         Verts_loss_se = sqrt(Mammals_loss_SE^2 + Birds_loss_SE^2 + Amphibians_loss_SE^2 + Reptiles_loss_SE^2),
         Total_loss = Mammals_loss + Birds_loss + Amphibians_loss + Reptiles_loss + Plants_loss,
         Total_loss_se = sqrt(Mammals_loss_SE^2 + Birds_loss_SE^2 + Amphibians_loss_SE^2 + Reptiles_loss_SE^2 + Plants_loss_SE^2))
# Data pivotted longer. 
Biodiversity_impact7 <- Biodiversity_impact5 %>%
  group_by(Ecoregion) %>%
  summarise_all(~ ifelse(is.numeric(.), sum(., na.rm = TRUE), first(.))) %>%
  subset(select = c(1,3,5,7,9,11,13)) %>%
  pivot_longer(cols = c(2:7),
               names_to = "Taxon",
               values_to = "Species_loss") 
# Another selection - to then calculate ratios
Biodiversity_impact8 <- Biodiversity_impact3 %>%
  subset(select = c("Ecoregion", "CF_type",
                    "Mammals_org_loss", "BAU_Existing_Mammals_Int",
                    "Birds_org_loss", "BAU_Existing_Birds_Int",
                    "Amphibians_org_loss", "BAU_Existing_Amphibians_Int",
                    "Reptiles_org_loss", "BAU_Existing_Reptiles_Int",
                    "Plants_org_loss", "BAU_Existing_Plants_Int"))
# Calculating ratios
Biodiversity_impact11 <- Biodiversity_impact3 %>%
  group_by(Ecoregion) %>%
  summarise_all(~ ifelse(is.numeric(.), sum(., na.rm = TRUE), first(.))) %>%
  mutate(Ratio_mammals = Mammals_org_loss / BAU_Existing_Mammals_Int,
         Ratio_mammals_se = ratio_se(Mammals_org_loss, BAU_Existing_Mammals_Int, Mammals_org_loss_SE, BAU_Existing_Mammals_Int_SE),
         Ratio_birds = Birds_org_loss / BAU_Existing_Birds_Int,
         Ratio_birds_se = ratio_se(Birds_org_loss, BAU_Existing_Birds_Int, Birds_org_loss_SE, BAU_Existing_Birds_Int_SE),
         Ratio_amphibians = Amphibians_org_loss / BAU_Existing_Amphibians_Int,
         Ratio_amphibians_se = ratio_se(Amphibians_org_loss, BAU_Existing_Amphibians_Int, Amphibians_org_loss_SE, BAU_Existing_Amphibians_Int_SE),
         Ratio_reptiles = Reptiles_org_loss / BAU_Existing_Reptiles_Int,
         Ratio_reptiles_se = ratio_se(Reptiles_org_loss, BAU_Existing_Reptiles_Int, Reptiles_org_loss_SE, BAU_Existing_Reptiles_Int_SE),
         Ratio_plants = Plants_org_loss / BAU_Existing_Plants_Int,
         Ratio_plants_se = ratio_se(Plants_org_loss, BAU_Existing_Plants_Int, Plants_org_loss_SE, BAU_Existing_Plants_Int_SE)) %>%
  subset(select = c(1, 91:100))
# Average ratios
Biodiversity_impact11_2 <- Biodiversity_impact11 %>%
  mutate(Ecoregion_verts = (Ratio_mammals + Ratio_birds + Ratio_amphibians + Ratio_reptiles) / 4,
         Ecoregion_total = (Ratio_mammals + Ratio_birds + Ratio_amphibians + Ratio_reptiles + Ratio_plants) / 5)
# Total loss across various groups
Biodiversity_impact12 <- Biodiversity_impact3 %>%
  group_by(Ecoregion) %>%
  summarise_all(~ ifelse(is.numeric(.), sum(., na.rm = TRUE), first(.))) %>%
  mutate(Total_org_loss = Mammals_org_loss + Birds_org_loss + Amphibians_org_loss + Reptiles_org_loss + Plants_org_loss,
         Total_org_loss_se = sqrt(sum(Mammals_org_loss_SE^2, Birds_org_loss_SE^2, Amphibians_org_loss_SE^2, Reptiles_org_loss_SE^2, Plants_org_loss_SE^2)),
         Total_BAU_loss = BAU_Existing_Mammals_Int + BAU_Existing_Birds_Int + BAU_Existing_Amphibians_Int + BAU_Existing_Reptiles_Int + BAU_Existing_Plants_Int,
         Total_BAU_loss_se = sqrt(sum(BAU_Existing_Mammals_Int_SE, BAU_Existing_Birds_Int_SE, BAU_Existing_Amphibians_Int_SE, BAU_Existing_Reptiles_Int_SE, BAU_Existing_Plants_Int_SE)),
         Total_ratio = Total_org_loss / Total_BAU_loss,
         Total_ratio_se = ratio_se(Total_org_loss, Total_BAU_loss, Total_org_loss_se, Total_BAU_loss_se))
# Summing to get total values 
Biodiversity_impact13 <- Biodiversity_impact12 %>%
  mutate(new_col = "A") %>%
  subset(select = c("Ecoregion", "CF_type", "new_col", "Total_org_loss", "Total_org_loss_se", "Total_BAU_loss", "Total_BAU_loss_se")) %>%
  summarise(Total_org_loss = sum(Total_org_loss),
            Total_org_loss_se = sqrt(sum(Total_org_loss_se^2)),
            Total_BAU_loss = sum(Total_BAU_loss),
            Total_BAU_loss_se = sqrt(sum(Total_BAU_loss_se^2))) %>%
  mutate(Loss_factor_SL = Total_org_loss / Total_BAU_loss,
         Loss_factor_SL_se = ratio_se(Total_org_loss, Total_BAU_loss, Total_org_loss_se, Total_BAU_loss_se))
# Across ecoregions
Biodiversity_ecoregions <- Biodiversity_impact5 %>%
  group_by(Ecoregion) %>%
  summarise_all(~ ifelse(is.numeric(.), sum(., na.rm = TRUE), first(.))) %>%
  mutate(PC_total_verts = Verts_loss / Biodiversity_total$Verts_loss,
         PC_total_verts_se = ratio_se(Verts_loss, Biodiversity_total$Verts_loss, Verts_loss_se, Biodiversity_total$Verts_loss_se),
         PC_total_plants = Plants_loss / Biodiversity_total$Plants_loss,
         PC_total_plants_se = ratio_se(Plants_loss, Biodiversity_total$Plants_loss, Plants_loss_SE, Biodiversity_total$Plants_loss_SE),
         PC_total_total = Total_loss / Biodiversity_total$Total_loss,
         PC_total_total_se = ratio_se(Total_loss, Biodiversity_total$Total_loss, Total_loss_se, Biodiversity_total$Total_loss_se))
Biodiversity_total <-  Biodiversity_impact5 %>%
  summarise_all(~ ifelse(is.numeric(.), sum(., na.rm = TRUE), first(.)))
# 5.2. Making biodiversity graphs --------------------------------------------
  # Taxa images
img1 <- pick_phylopic(name = "Elephas maximus", n = 1) # elephant
img1 <- get_phylopic(uuid = "db278f3b-d8c1-47e9-afce-0478980f5875")

img2 <- pick_phylopic(name = "Polypedates", n = 1) # frog
img2 <- get_phylopic(uuid = "37799557-38c3-4743-99f9-4274bbcc6e9a")

img3 <- pick_phylopic(name = "Chamaeleo", n = 1) # chameleon
img3 <- get_phylopic(uuid = "5346cae2-1543-4aeb-9ef0-7d67005749c3")

img4 <- pick_phylopic(name = "Pandanus", n = 1) # tree
img4 <- get_phylopic(uuid = "30375f96-02aa-4198-8d27-0f5db037b09a")

img5 <- pick_phylopic(name = "Urocissa", n = 1) # Sri Lankan blue magpie
img5 <- get_phylopic(uuid = "f51db955-33ed-4846-b8cf-e5b4c8217ced")
# 5.2.2. Vertebrate loss map ---------------------------------------------------
  # Formatting data
Biodiversity_impact_graph <- Biodiversity_impact5 %>%
  group_by(Ecoregion) %>%
  summarise(Verts_loss = sum(Verts_loss),
            Plants_loss = sum(Plants_loss))
Map_ecoregions3 <- left_join(Map_ecoregions, Biodiversity_impact_graph, by = "Ecoregion")
Map_ecoregions4 <- Map_ecoregions3 %>%
  filter(Taxon == "Verts_loss")
  # Vertebrate loss map
main_verts <- ggplot(Map_ecoregions3) +
  geom_sf(color = NA, aes(fill = Verts_loss)) +    
  coord_sf(xlim = c(79.5, 82), ylim = c(5.8, 9.9), expand = FALSE) +    
  labs(title = "Potential Vertebrate Species Loss \nby Ecoregion") +    
  theme_minimal() +
  theme(plot.margin = unit(c(1, 2, 2, 2), "cm"),
        plot.title = element_text(size = 22, hjust = 0.5, face = "bold"),
        axis.title = element_blank(),
        axis.text = element_blank(),
        panel.grid.major = element_blank(),
        legend.text = element_text(size = 15),
        legend.title = element_text(size = 17),
        legend.key.width = unit(0.2, "npc")) +
  annotate("text", x = 80.79, y = 9.75, label = "Deccan Thorn \nScrub Forests", color = "black", size = 4.5,  lineheight = 0.9)+
  annotate("text", x = 80.65, y = 8.3, label = "Dry Zone Dry \nEvergreen Forests", color = "black", size = 4.5, lineheight = 0.9) +
  annotate("text", x = 80.35, y = 6.6, label = "Lowland \nRain Forests", color = "white", size = 4.5, lineheight = 0.9) +
  annotate("text", x = 80.775, y = 6.9, label = "Montane \nRain Forests", color = "black", size = 4.5, lineheight = 0.9) +
  geom_segment(aes(x = 80.28, xend = 80.43, y = 9.75, yend = 9.75), linetype = "solid", color = "black")
  # Adding legend to vertebrate loss map
main_verts <- main_verts + theme(legend.key.width = unit(0.17, "npc"),
                                 legend.position = c(0.5, -0.05),) +
  scale_fill_viridis_c(name = "Potential Species Loss",
                       guide = guide_colorbar(
                         title.position = "top", 
                         title.hjust = 0.5,
                         label.position = "bottom",
                         label.hjust = 0.5,
                         direction = "horizontal",
                         barheight = unit(4, "mm"),
                         ticks = FALSE,
                         nbin = 100),
                       option = "viridis",
                       direction = -1
  )
# 5.2.3. Plant loss map --------------------------------------------------------
main_plants <- ggplot(Map_ecoregions3) +
  geom_sf(color = NA, aes(fill = Plants_loss)) +    
  coord_sf(xlim = c(79.5, 82), ylim = c(5.8, 9.9), expand = FALSE) +    
  labs(title = "Potential Plant Species Loss \nby Ecoregion") +    
  theme_minimal() +
  theme(plot.margin = unit(c(1, 2, 2, 2), "cm"),
        plot.title = element_text(size = 22, hjust = 0.5, face = "bold"),
        axis.title = element_blank(),
        axis.text = element_blank(),
        panel.grid.major = element_blank(),
        legend.text = element_text(size = 15),
        legend.title = element_text(size = 17),
        legend.key.width = unit(0.2, "npc")) +
  annotate("text", x = 80.79, y = 9.75, label = "Deccan Thorn \nScrub Forests", color = "black", size = 4.5,  lineheight = 0.9)+
  annotate("text", x = 80.65, y = 8.3, label = "Dry Zone Dry \nEvergreen Forests", color = "white", size = 4.5, lineheight = 0.9) +
  annotate("text", x = 80.35, y = 6.6, label = "Lowland \nRain Forests", color = "white", size = 4.5, lineheight = 0.9) +
  annotate("text", x = 80.775, y = 6.9, label = "Montane \nRain Forests", color = "white", size = 4.5, lineheight = 0.9) +
  geom_segment(aes(x = 80.28, xend = 80.43, y = 9.75, yend = 9.75), linetype = "solid", color = "black")
# Adding legend to plant loss map
main_plants <- main_plants + theme(legend.key.width = unit(0.17, "npc"),
                                   legend.position = c(0.5, -0.05),) +
  scale_fill_viridis_c(name = "Potential Species Loss",
                       guide = guide_colorbar(
                         title.position = "top", 
                         title.hjust = 0.5,
                         label.position = "bottom",
                         label.hjust = 0.5,
                         direction = "horizontal",
                         barheight = unit(4, "mm"),
                         ticks = FALSE,
                         nbin = 100),
                       option = "viridis",
                       direction = -1,
                       limits = c(0,250)
  )
# Adding taxa pics to both maps
main_verts + 
  add_phylopic(img = img1, color = "grey55", alpha = .8, x = 81.95, y = 9.65, ysize = 0.3) +
  add_phylopic(img = img5, color = "grey55", alpha = .8, x = 81.95, y = 9.30, ysize = 0.25) +
  add_phylopic(img = img2, color = "grey55", alpha = .8, x = 81.95, y = 8.90, ysize = 0.3) +
  add_phylopic(img = img3, color = "grey55", alpha = .8, x = 81.95, y = 8.50, ysize = 0.3) 

main_plants + 
  add_phylopic(img = img4, color = "grey55", alpha = .8, x = 81.95, y = 9.65, ysize = 0.3) 
# 5.2.4. Bar charts (species loss by taxon and ecoregion) ----------------------
# Formatting data
Biodiversity_plot <- Biodiversity_impact4 %>%
  group_by(Ecoregion) %>%
  summarise_all(~ ifelse(is.numeric(.), sum(., na.rm = TRUE), first(.)))%>%
  pivot_longer(cols = -c(Ecoregion, CF_type),
               names_to = c("Taxon", ".value"),
               names_pattern = "([A-Za-z]+)_([A-Za-z_]+)") %>%
  filter(Taxon != "Plants") %>%
  mutate(Taxon = fct_relevel(Taxon, "Amphibians", "Mammals", "Birds", "Reptiles"),
         Ecoregion = fct_relevel(Ecoregion, "Deccan Thorn Scrub Forests", "Sri Lanka Dry-Zone Dry Evergreen Forests", "Sri Lanka Montane Rain Forests", "Sri Lanka Lowland Rain Forests"))
# Vertebrate species loss bar chart
ggplot(Biodiversity_plot, aes(x = Taxon, y = loss, fill = Ecoregion)) +
  geom_bar(stat = "identity", position = "stack", width = 0.5) +
  theme_classic() +
  labs(x = "Taxon", y = "Potential Species Loss", title = "Potential Species Loss by Taxon") +
  scale_fill_viridis(discrete = TRUE, option = "viridis",
                     guide = guide_legend(title.position = "top",
                                          title.hjust = 0.5,
                                          nrow = 2)) +
  scale_y_continuous(limits = c(0, 105), expand = c(0, 0)) +
  theme(legend.position = "bottom",
        plot.title = element_text(size = 22, hjust = 0.5, face = "bold"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.text = element_text(size = 17),
        axis.title = element_text(size = 20),
        legend.title = element_text(size = 17),
        legend.text = element_text(size = 15)) +
  add_phylopic(img = img1, color = "grey55", alpha = .8, x = 2, y = 29, ysize = 6) +
  add_phylopic(img = img2, color = "grey55", alpha = .8, x = 1, y = 103, ysize = 6) +
  add_phylopic(img = img3, color = "grey55", alpha = .8, x = 4, y = 21, ysize = 6) +
  add_phylopic(img = img5, color = "grey55", alpha = .8, x = 3, y = 28.5, ysize = 6)
  # Formatting data for plants
Biodiversity_plot2 <- Biodiversity_impact4 %>%
  group_by(Ecoregion) %>%
  summarise_all(~ ifelse(is.numeric(.), sum(., na.rm = TRUE), first(.)))%>%
  pivot_longer(cols = -c(Ecoregion, CF_type),
               names_to = c("Taxon", ".value"),
               names_pattern = "([A-Za-z]+)_([A-Za-z_]+)") %>%
  filter(Taxon == "Plants") 
  # Plant species loss bar chart
ggplot(Biodiversity_plot2, aes(x = Taxon, y = loss, fill = Ecoregion)) +
  geom_bar(stat = "identity", position = "stack", width = 0.5) +
  theme_classic() +
  labs(x = "Taxon", y = "", title = "Potential Species Loss by Taxon") +
  scale_fill_viridis(discrete = TRUE, 
                     guide = guide_legend(title.position = "top",
                                          title.hjust = 0.5,
                                          nrow = 2)) +
  scale_y_continuous(limits = c(0, 700), expand = c(0, 0)) +
  theme(legend.position = "bottom",
        plot.title = element_text(size = 22, hjust = 0.5, face = "bold"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.text = element_text(size = 17),
        axis.title = element_text(size = 20),
        legend.title = element_text(size = 17),
        legend.text = element_text(size = 15)) +
  add_phylopic(img = img4, color = "grey55", x = 1, y = 670, ysize = 50) + 
  geom_segment(aes(x = 1.33, y = 642.4372*(1/2.242714), xend = 1.28, yend = 642.4372*(1/2.242714)),
               arrow = arrow(length = unit(0.25, "cm"), type = "closed"),  # Adjust the length as desired
               lineend = "butt",
               color = "grey55", 
               alpha = 0.8,
               size = 1) 



# SECTION 6 - NUTRITION
# 5.1. Production change without land increase ---------------------------------
## Calculation: pre-ban land * post-ban yield
Nutrition_impact1 <- Production_model_joined_sown %>%
  mutate(Production_no_land_increase = Mean_net_land_no_ban * Predicted_yield_ban,
         Production_no_land_increase_se = product_se(Mean_net_land_no_ban, Predicted_yield_ban, Mean_net_land_no_ban_se, Predicted_yield_ban_se))
# Tidying (selecting columns)
Nutrition_impact1 <- Nutrition_impact1 %>%
  subset(select = c(1:6, 34,35))
# Values for SL as a whole (collapsing down irrigation types, regions and maha/yala)
Nutrition_impact2 <- Nutrition_impact1 %>%
  summarise(Total_prod_pre_ban = sum(Mean_prod_5y),
            Total_prod_pre_ban_se = sqrt(sum(Mean_prod_5y_sem^2)),
            
            Total_prod_post_ban = sum(Production_no_land_increase),
            Total_prod_post_ban_se = sqrt(sum(Production_no_land_increase_se^2, na.rm = T))) %>%
  mutate(Difference = Total_prod_post_ban - Total_prod_pre_ban,
         PC_difference = Difference / Total_prod_pre_ban,
         Difference_se = add_subt_se(Total_prod_post_ban_se, Total_prod_pre_ban_se),
         PC_difference_se = ratio_se(Total_prod_post_ban, Total_prod_pre_ban, Total_prod_post_ban_se, Total_prod_pre_ban_se))
# 5.1.2. Converting from paddy to raw rice for food ------------------------------
## My value are for paddy. From the Crop Cutting Survey, converting paddy to rice:
### Paddy * 0.94 (6% loss of paddy when converting it to rice, e.g., in combine harvester)
### Remaining * 0.973 (2.7% needed for seed requirements for next harvest)
### Remaining * 0.68 (paddy is heavier than rice because you remove the husk and the bran)
### Remaining * 0.986 (1.4% loss after harvesting)
Nutrition_impact3 <- Nutrition_impact2 %>%    # Might change these assumptions
  subset(select = c(1:4)) %>%
  pivot_longer(cols = c(1:4),
               names_to = "Production_category",
               values_to = "Paddy_production_kg") %>%
  mutate(Paddy_harvested_kg = Paddy_production_kg * 0.94, 
         Paddy_harvested_excl_seeds_kg = Paddy_harvested_kg * 0.973,
         Raw_rice_kg = Paddy_harvested_excl_seeds_kg * 0.68,
         Rice_food_kg = Raw_rice_kg * 0.986)    # Assuming 1.4% loss after harvesting (harvest -> retail -> consumer) - Andhra Pradesh FAO report
# 5.1.3. Rice per capita -------------------------------------------------------
## Pre ban: using 2016-2020 average population
## Post ban: using latest value (2021) for population
## Data from World Population Prospects 2022 (UN) - seems to be most trusted source, e.g., Our World in Data uses it for 1950 onwards populations
  # Pre-ban population
Pre_ban_pop <- data_population %>%
  filter(Year%in% c("2016", "2017", "2018", "2019", "2020")) %>%
  summarise(Pre_ban_pop = mean(Population_UN_World_Population_Prospects)) 
  # Post ban population
Post_ban_pop <- data_population %>%
  filter(Year == "2021") %>%
  rename(Post_ban_pop = Population_UN_World_Population_Prospects)
  # Working out rice per capita
Nutrition_impact4 <- Nutrition_impact3 %>%
  mutate(Rice_per_capita_pre_ban = Rice_food_kg / Pre_ban_pop$Pre_ban_pop,
         Rice_per_capita_post_ban = Rice_food_kg / Post_ban_pop$Post_ban_pop)
  # Formatting data
Nutrition_impact5 <- Nutrition_impact4 %>%
  mutate(Rice_per_capita = case_when(
    row_number() %in% c(1,2) ~ Rice_per_capita_pre_ban,
    TRUE ~ Rice_per_capita_post_ban
  )) %>%
  subset(select = c(1,9))
Nutrition_impact6 <- Nutrition_impact5 %>%
  pivot_wider(names_from = "Production_category", values_from = "Rice_per_capita") %>%
  mutate(Difference = Total_prod_pre_ban - Total_prod_post_ban,
         Difference_se = add_subt_se(Total_prod_pre_ban_se, Total_prod_post_ban_se))
# 5.1.4. Convert to calories ----------------------------------------------------------
## Rice in SL is split by type: long and short grain, red and white pericarp, parboiled or not parboiled. 
## Following Liyanaarachchi et al 2020 (http://dx.doi.org/10.4038/jnsfsr.v48i2.9565), I've determined meaning of the names of the main varieties:
## Rathu = red; Sudu = white; Samba = short; default = long; Nadu / thambapu = parboiled; Kekulu = not parboiled. 
## Following Liyanaarachchi et al 2020 and using GOSL latest Income and Expenditure Report (2019), I worked out proportion by variety (www.statistics.gov.lk/IncomeAndExpenditure/StaticalInformation/HouseholdIncomeandExpenditureSurvey2019FinalReport)
## Used rice nutrition values from latest India report (2017), but supplemented with data on red rice. 
  # Data_rice_var - from Income and Expenditure Report 2019
    ## It's got information on monthly household consumption by variety. Unit doesn't matter, just need the proportion for each type.
data_rice_var <- data_rice_var %>%
  mutate(Var_pc = (Value / sum(Value)) * 100)
  # Parboiled vs raw split:
data_rice_var2 <- data_rice_var %>%
  group_by(Parboiled_status) %>%
  summarise(Sum = sum(Value)) %>%
  mutate(Proportion = Sum / sum(Sum))
  # Join with per capita rice consumption
Nutrition_impact7 <- 
  Nutrition_impact6[rep(1, nrow(data_rice_var2)), ] 
  # Yearly and day pre- and post- ban, and difference (kg and g)
data_rice_var_per_capita <- bind_cols(data_rice_var2, Nutrition_impact7) %>%
  mutate(Pre_ban_per_capita_yr_kg = Proportion * Total_prod_pre_ban,
         Pre_ban_per_capita_yr_kg_se = Proportion * Total_prod_pre_ban_se,
         Post_ban_per_capita_yr_kg = Proportion * Total_prod_post_ban, 
         Post_ban_per_capita_yr_kg_se = Proportion * Total_prod_post_ban_se,
         
         Pre_ban_per_capita_day_g = (Pre_ban_per_capita_yr_kg / 365) * 1000,
         Pre_ban_per_capita_day_g_se = (Pre_ban_per_capita_yr_kg_se / 365) * 1000,
         Post_ban_per_capita_day_g = (Post_ban_per_capita_yr_kg / 365) * 1000,
         Post_ban_per_capita_day_g_se = (Post_ban_per_capita_yr_kg_se / 365) * 1000,
         
         Difference_per_capita_yr_kg = Proportion * Difference,
         Difference_per_capita_yr_kg_se = Proportion * Difference_se,
         Difference_per_capita_day_g = (Difference_per_capita_yr_kg / 365) * 1000,
         Difference_per_capita_day_g_se = (Difference_per_capita_yr_kg_se / 365) * 1000,
         Parboiled_status = c("Rice, parboilled, milled", "Rice, raw, milled")) %>%
  rename("Category" = "Parboiled_status") %>%
  subset(select = c("Category",
                    "Pre_ban_per_capita_day_g", "Pre_ban_per_capita_day_g_se", 
                    "Post_ban_per_capita_day_g", "Post_ban_per_capita_day_g_se", 
                    "Difference_per_capita_day_g", "Difference_per_capita_day_g_se"))
  # Data_rice_nutri - from Indian Food Composition Tables (2017)
    ## Rice data is for raw (uncooked) rice, per 100g
  # Tidying data (because the error is contained in the same value as the estimate, makes it tricky to use)
cols_to_separate <- colnames(data_rice_nutri)[2:32]    # designating columns to be separated
for (col in cols_to_separate) {    # loop that separates out the columns
  new_col_names <- c(paste0("est_", col), paste0("err_", col))
  data_rice_nutri <- data_rice_nutri %>%
    separate(col, into = new_col_names, sep = " \\+/- ", remove = FALSE)
}
colnames(data_rice_nutri)[2:94] <- gsub(" \\+/- error", "", colnames(data_rice_nutri)[2:94])    # tidies column names
data_rice_nutri2 <- data_rice_nutri %>%    # Then I had to exclude the original columns; defs a better way of doing this but oh well
  subset(select = c(1,3,4,6,7,9,10,12,13,15,16,18,19,21,22,24,25,27,28,30,31,33,34,36,37,39,40,42,43,45,46,48,49,51,52,54,55,57,58,60,61,63,64,66,67,69,70,72,73,75,76,78,79,81,82,84,85,87,88,90,91,93,94))
  # Joining with reduction per capita
data_rice_nutri3 <- left_join(data_rice_var_per_capita, data_rice_nutri2, by = "Category") %>%
  mutate_at(vars(8:69), as.numeric)
  # Working out impacts (used in write up)
data_rice_nutri3_wu <- data_rice_nutri3 %>%
  subset(select = c(1:7, 24, 25)) %>%
  mutate(Energy_reduc_KJ = est_Energy_KJ * (Difference_per_capita_day_g / 100),
         Energy_reduc_KJ_se = product_se(est_Energy_KJ, (Difference_per_capita_day_g / 100), err_Energy_KJ, Difference_per_capita_day_g_se / 100),
         Energy_reduc_kcal = Energy_reduc_KJ / 4.184,
         Energy_reduc_kcal_se = Energy_reduc_KJ_se / 4.184)
data_rice_nutri3_wu2 <- data_rice_nutri3_wu %>%
  subset(select = c(6,7,12,13)) %>%
  summarise(Difference_per_capita_day_g = sum(Difference_per_capita_day_g),
            Difference_per_capita_day_g_se = sqrt(sum(Difference_per_capita_day_g_se^2)),
            Energy_reduc_kcal = sum(Energy_reduc_kcal),
            Energy_reduc_kcal_se = sqrt(sum(Energy_reduc_kcal_se^2)))
# 5.2. Even spread impact on undernutrition ------------------------------------------------
# From:
  ## 3.4% of population suffers from undernutrition, i.e., too few calories in 2019-2021
  ## This is pre-ban as it uses middle of 2021 for 2021 value
  ## Can approximate calorie distribution as normal.  
  # From: https://www.fao.org/faostat/en/#data/FS
  ## Average minimum dietary energy requirement is 1780 calories (average 2019-2021 value)
  ### Below this, people have (on average) insufficient caloriesav for a healthy lifestyle. 
  ## Average dietary energy requirement is 2293 calories (average 2019-2021 value)
  ## And pre-ban average energy supply was 2833 calories (2019-2021)
  # Assuming:
  ## Reduction in calories is homogenous across population after the ban. 
# 5.2.1. Normal distribution calculations --------------------------------------
  # Values:
Fraction_undernourished <- 0.034
MDER_cal <- 1780    # From FAO data, average 2019-2021
AES_cal_pre <- 2833    # From FAO data, average 2019-2021
Ban_cal_shift <- 311.204     # My calc, from Nutrition script
  # How many standard deviations below the mean (2833) is the MDER (1780)?
MDER_sd <- qnorm(Fraction_undernourished)    ## -1.825007 SD 
  # This is at position:
MDER_pos <- AES_cal_pre - MDER_cal    # 1053
  # Hence, standard deviation of distribution is:
Distrib_SD <- MDER_pos / MDER_sd
Distrib_SD
  # Calories after the ban 
AES_cal_post <- AES_cal_pre - Ban_cal_shift
  # Post ban MDER Z score:
Post_ban_Z <- (MDER_cal - AES_cal_post) / Distrib_SD
  # Therefore, new % of people below MDER
New_fraction_undernourished <- 1 - pnorm(Post_ban_Z)
New_fraction_undernourished
# 5.2.2. Making plot -----------------------------------------------------------
  # Create a data frame with x values and densities for both distributions
df <- data.frame(x = seq(0, 5000, length.out = 1000))
df$y1 <- dnorm(df$x, AES_cal_pre, (-1*Distrib_SD))
df$y2 <- dnorm(df$x, AES_cal_post, (-1*Distrib_SD))
  # Notation (proper scientific notation)
fancy_scientific <- function(l) {
  # turn in to character string in scientific notation
  l <- format(l, scientific = TRUE)
  # quote the part before the exponent to keep all the digits
  l <- gsub("^(.*)e", "'\\1'e", l)
  # turn the 'e+' into plotmath format
  l <- gsub("e", "%*%10^", l)
  # return this as an expression
  parse(text=l)
}
  # Plot the densities using ggplot2
ggplot(df, aes(x = x)) +
  # Shade the area less than MDER in gray
  geom_ribbon(data = subset(df, x <= MDER_cal), aes(ymin = y1, ymax = y2, fill = "Additional after the ban"), alpha = 0.5) +
  geom_ribbon(data = subset(df, x <= MDER_cal), aes(ymin = y1, ymax = 0, fill = "Before the ban"), alpha = 0.5) +
  geom_line(aes(y = y1, color = "Before the ban"), size = 2.5) +
  geom_line(aes(y = y2, color = "After the ban"), size = 2.5) +
  # Add a vertical line at MDER
  geom_vline(xintercept = 1780, linetype = "dashed") +
  # Add the legend
  #scale_fill_manual(values = c("grey22", "grey"), name = "Proportion of population malnourished") +
  scale_fill_manual(values = c("grey22", "grey"), #name = "Proportion of population malnourished",
                    labels = c("Increase after the ban", "Before the ban")) +
  scale_color_manual(values = c("Before the ban" = "#fde725", "After the ban" = "#440154"),
                     #name = "Proportion of population malnourished",
                     labels = c("After the ban", "Before the ban")) +
  # Set the x and y limits
  xlim(0, 5000) +
  scale_y_continuous(limits = c(0,0.00075), expand = c(0,0), labels = fancy_scientific) +
  # Add labels and a title
  labs(x = "Calories per person per day ", 
       y = "Density", 
       title = "Impacts of the Even-Spread Scenario on Rice Consumption",
       fill = "Proportion of population malnourished",
       color = "Calorie distribution in population") +
  annotate("text", x = 150, y = max(df$y1, df$y2) * 0.95, label = "Below average minimum\ndaily energy requirement\n(1780 kcal/day)",
           hjust = 0, size = 6) +
  geom_segment(aes(x = 2833, y = 7.02e-04, xend = 2833-311, yend = 7.02e-04),
               arrow = arrow(length = unit(0.3, "cm"), type = "closed"), color = "grey33", size = 0.8) +
  geom_segment(aes(x = 2220, y = 4.04e-04, xend = 2220-280, yend = 4.04e-04),
               arrow = arrow(length = unit(0.3, "cm"), type = "closed"), color = "grey33", size = 0.8) +
  theme_classic() +
  theme(plot.title = element_blank(),
        axis.title = element_text(size = 20),
        axis.text = element_text(size = 17),
        legend.title = element_text(size = 17),
        legend.text = element_text(size = 15),
        legend.position = "bottom",
        legend.box = "vertical",
        legend.margin = margin(t = 0, r = 10, b = 0, l = 10),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        legend.title.align = 0.5) +
  guides(fill = guide_legend(title.position = "top", title.hjust=0.5),
         color = guide_legend(title.position = "top", title.hjust=0.5))
# 5.3. Weighted spread impact on undernutrition
  # This builds on my Excel spreadsheet
# 5.3.1. Weighted spread graph:
Top <- 0    # Upper limit for elasticity 
Bottom <- -1    # Lower limit for elasticity
Steppiness <- 1.6    # Small = smooth, large = near step function
Centre <- 5.5    # This decile has elasticity (Top - Bottom) / 2; i.e. at inflection point of S shaped curve
Pre_shock_price <- 100    
Post_shock_price <- 233.672394262689    
# Pre-ban consumption data
Decile <- c(1,2,3,4,5,6,7,8,9,10)
Consumption_pre_ban_hh <- c(16.3, 26.3, 30, 33.5, 33.7, 34.96, 34.96, 34.96, 34.96, 34.96)
Weighted_scen <- as_tibble(cbind(Decile, Consumption_pre_ban_hh)) %>%
  mutate(Consumption_pre_ban_pp_day = Consumption_pre_ban_hh * (3148.922 / sum(16.3, 26.3, 30, 33.5, 33.7, 34.96, 34.96, 34.96, 34.96, 34.96))) %>%
  subset(select = c(1,3)) %>%
  mutate(Elasticities = Bottom + (Top - Bottom) / (1 + exp(Steppiness*(Centre - Decile)))) %>%
  mutate(Consumption_post_ban_pp_day = ((Post_shock_price / Pre_shock_price)^Elasticities) * Consumption_pre_ban_pp_day) %>%
  mutate(Difference = (Consumption_pre_ban_pp_day - Consumption_post_ban_pp_day) * 3.537729)
# Formatting data for graph
Weighted_scen_graph <- Weighted_scen %>%
  pivot_longer(cols = c(2,4), names_to = "Ban_status", values_to = "Consumption") %>%
  mutate(Consumption_cal= Consumption * 3.537729)

ggplot(Weighted_scen_graph, aes(x = Decile, y = Consumption_cal, color = Ban_status)) +
  geom_line(data = subset(Weighted_scen_graph, Ban_status == "Consumption_pre_ban_pp_day"),
            aes(group = 1), size = 2.5, alpha = 1) +
  geom_line(data = subset(Weighted_scen_graph, Ban_status == "Consumption_post_ban_pp_day"),
            aes(group = 1), size = 2.75, alpha = 1) +
  geom_segment(data = Weighted_scen_graph %>% group_by(Decile) %>% mutate(
    y1 = Consumption_cal[Ban_status == "Consumption_pre_ban_pp_day"],
    y2 = Consumption_cal[Ban_status == "Consumption_post_ban_pp_day"]),
    aes(x = Decile, xend = Decile, y = y1, yend = y2),linetype = "dotted", colour = "grey33") +  # Add vertical dotted lines between points
  # annotate("text", x = c(1.5, 2.5, 3.5, 4.5, 5.5, 6.5, 7.5), y = 0,
  #         label = c("-330", "-531", "-601", "-641", "-529", "-286", "-84")) +  # Add numbers in the middle
  geom_point(size = 4, alpha = 1) +
  scale_x_continuous(breaks = c(1,2,3,4,5,6,7,8,9,10)) +
  scale_y_continuous(expand = c(0,0), limits = c(0, 1300)) +
  labs(x = "Expenditure Decile", 
       y = "Calories from rice per person per day (kcal)") +
  scale_color_manual(values = c("#440154", "#fde725"),
                     name = "Ban status",
                     labels = c("After the ban", "Before the ban")) +
  theme_classic() +
  theme(plot.title = element_blank(),
        axis.title = element_text(size = 20),
        axis.text = element_text(size = 17),
        legend.title = element_text(size = 17),
        legend.text = element_text(size = 15),
        legend.position = "bottom",
        legend.box = "vertical",
        legend.margin = margin(t = 0, r = 10, b = 0, l = 10),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        legend.title.align = 0.5) +
  guides(color = guide_legend(title.position = "top", title.hjust=0.5,
                              reverse = TRUE)) # reverse the order of the legend labels

